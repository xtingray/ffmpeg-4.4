configure:libaom_av1_encoder_select="extract_extradata_bsf"
configure:librav1e_encoder_select="extract_extradata_bsf"
doc/encoders.texi:Place global headers in extradata instead of every keyframe.
doc/ffmpeg.texi:Technical note -- attachments are implemented as codec extradata, so this
doc/ffmpeg.texi:option can actually be used to extract extradata from any stream, not just
doc/ffprobe.xsd:      <xsd:attribute name="extradata"        type="xsd:string" />
doc/ffprobe.xsd:      <xsd:attribute name="extradata_hash"   type="xsd:string" />
doc/muxers.texi:filter is used to add extradata information to all the output video
doc/examples/qsvdec.c:    if (video_st->codecpar->extradata_size) {
doc/examples/qsvdec.c:        decoder_ctx->extradata = av_mallocz(video_st->codecpar->extradata_size +
doc/examples/qsvdec.c:        if (!decoder_ctx->extradata) {
doc/examples/qsvdec.c:        memcpy(decoder_ctx->extradata, video_st->codecpar->extradata,
doc/examples/qsvdec.c:               video_st->codecpar->extradata_size);
doc/examples/qsvdec.c:        decoder_ctx->extradata_size = video_st->codecpar->extradata_size;
doc/config.texi:@set config-dump-extradata-bsf yes
doc/config.texi:@set config-extract-extradata-bsf yes
doc/config.texi:@set config-remove-extradata-bsf yes
doc/codecs.texi:Place global headers in extradata instead of every keyframe.
doc/codecs.texi:Place global headers at every keyframe instead of in extradata.
doc/bitstream_filters.texi:Add extradata to the beginning of the filtered packets except when
doc/bitstream_filters.texi:said packets already exactly begin with the extradata that is intended
doc/bitstream_filters.texi:add extradata to all key packets
doc/bitstream_filters.texi:add extradata to all packets
doc/bitstream_filters.texi:the header stored in extradata to the key packets:
doc/bitstream_filters.texi:@section extract_extradata
doc/bitstream_filters.texi:Extract the in-band extradata.
doc/bitstream_filters.texi:container level). This latter form is called "extradata" in FFmpeg terminology.
doc/bitstream_filters.texi:extradata.
doc/bitstream_filters.texi:confuse other transformations which require correct extradata.
doc/bitstream_filters.texi:Remove extradata from packets.
doc/bitstream_filters.texi:Set which frame types to remove extradata from.
doc/bitstream_filters.texi:Remove extradata from non-keyframes only.
doc/bitstream_filters.texi:Remove extradata from keyframes only.
doc/bitstream_filters.texi:Remove extradata from all frames.
doc/ffprobe.texi:@option{-show_streams}, it will dump the codec extradata.
doc/ffprobe.texi:codec extradata with @option{-show_streams}.
doc/snow.txt:use extradata for stuff which is in the keyframes now?
doc/demuxers.texi:fcTL chunk are transmitted as extradata.
doc/libav-merge.txt:- avcodec/libaomenc: export the Sequence Header OBU as extradata (See a024c3ce9a)
ffbuild/config.log:dump_extradata_bsf
ffbuild/config.log:extract_extradata_bsf
ffbuild/config.log:remove_extradata_bsf
ffbuild/config.log:dump_extradata_bsf
ffbuild/config.log:extract_extradata_bsf
ffbuild/config.log:remove_extradata_bsf
ffbuild/config.log:dump_extradata_bsf
ffbuild/config.log:extract_extradata_bsf
ffbuild/config.log:remove_extradata_bsf
ffbuild/config.log:dump_extradata_bsf
ffbuild/config.log:extract_extradata_bsf
ffbuild/config.log:remove_extradata_bsf
ffbuild/config.log:dump_extradata_bsf='yes'
ffbuild/config.log:extract_extradata_bsf='yes'
ffbuild/config.log:libaom_av1_encoder_select='extract_extradata_bsf'
ffbuild/config.log:librav1e_encoder_select='extract_extradata_bsf'
ffbuild/config.log:remove_extradata_bsf='yes'
fftools/ffmpeg_opt.c:    if (!st->codecpar->extradata_size) {
fftools/ffmpeg_opt.c:        av_log(NULL, AV_LOG_WARNING, "No extradata to dump in stream #%d:%d.\n",
fftools/ffmpeg_opt.c:    avio_write(out, st->codecpar->extradata, st->codecpar->extradata_size);
fftools/ffmpeg_opt.c:        ost->st->codecpar->extradata      = attachment;
fftools/ffmpeg_opt.c:        ost->st->codecpar->extradata_size = len;
fftools/ffprobe.c:        writer_print_data(w, "extradata", par->extradata,
fftools/ffprobe.c:                                          par->extradata_size);
fftools/ffprobe.c:    writer_print_data_hash(w, "extradata_hash", par->extradata,
fftools/ffprobe.c:                                                par->extradata_size);
fftools/ffmpeg.c:        extra_size += ost->enc_ctx->extradata_size;
libavcodec/motionpixels.c:    if(avctx->extradata_size < 2){
libavcodec/motionpixels.c:        av_log(avctx, AV_LOG_ERROR, "extradata too small\n");
libavcodec/motionpixels.c:    for (i = !(avctx->extradata[1] & 2); i < 2; ++i) {
libavcodec/motionpixels.c:    if (avctx->extradata[0] != 5)
libavcodec/aacenc.c:    avctx->extradata = av_mallocz(max_size);
libavcodec/aacenc.c:    if (!avctx->extradata)
libavcodec/aacenc.c:    init_put_bits(&pb, avctx->extradata, max_size);
libavcodec/aacenc.c:    avctx->extradata_size = put_bits_count(&pb) >> 3;
libavcodec/libspeexdec.c:    if (avctx->extradata && avctx->extradata_size >= 80) {
libavcodec/libspeexdec.c:        header = speex_packet_to_header(avctx->extradata,
libavcodec/libspeexdec.c:                                        avctx->extradata_size);
libavcodec/libspeexdec.c:        if (!avctx->extradata || avctx->extradata && avctx->extradata_size < 47) {
libavcodec/libspeexdec.c:            av_log(avctx, AV_LOG_ERROR, "Missing or invalid extradata.\n");
libavcodec/libspeexdec.c:        quality = avctx->extradata[37];
libavcodec/utvideodec.c:    if (c->pack && avctx->extradata_size >= 16) {
libavcodec/utvideodec.c:               avctx->extradata[3], avctx->extradata[2],
libavcodec/utvideodec.c:               avctx->extradata[1], avctx->extradata[0]);
libavcodec/utvideodec.c:               AV_RB32(avctx->extradata + 4));
libavcodec/utvideodec.c:        c->compression = avctx->extradata[8];
libavcodec/utvideodec.c:        c->slices      = avctx->extradata[9] + 1;
libavcodec/utvideodec.c:    } else if (!c->pro && avctx->extradata_size >= 16) {
libavcodec/utvideodec.c:               avctx->extradata[3], avctx->extradata[2],
libavcodec/utvideodec.c:               avctx->extradata[1], avctx->extradata[0]);
libavcodec/utvideodec.c:               AV_RB32(avctx->extradata + 4));
libavcodec/utvideodec.c:        c->frame_info_size = AV_RL32(avctx->extradata + 8);
libavcodec/utvideodec.c:        c->flags           = AV_RL32(avctx->extradata + 12);
libavcodec/utvideodec.c:    } else if (c->pro && avctx->extradata_size == 8) {
libavcodec/utvideodec.c:               avctx->extradata[3], avctx->extradata[2],
libavcodec/utvideodec.c:               avctx->extradata[1], avctx->extradata[0]);
libavcodec/utvideodec.c:               AV_RB32(avctx->extradata + 4));
libavcodec/utvideodec.c:               "Insufficient extradata size %d, should be at least 16\n",
libavcodec/utvideodec.c:               avctx->extradata_size);
libavcodec/libopusdec.c:    avc->channels = avc->extradata_size >= 10 ? avc->extradata[9] : (avc->channels == 1) ? 1 : 2;
libavcodec/libopusdec.c:    if (avc->extradata_size >= OPUS_HEAD_SIZE) {
libavcodec/libopusdec.c:        opus->pre_skip = AV_RL16(avc->extradata + 10);
libavcodec/libopusdec.c:        gain_db     = sign_extend(AV_RL16(avc->extradata + 16), 16);
libavcodec/libopusdec.c:        channel_map = AV_RL8 (avc->extradata + 18);
libavcodec/libopusdec.c:    if (avc->extradata_size >= OPUS_HEAD_SIZE + 2 + avc->channels) {
libavcodec/libopusdec.c:        nb_streams = avc->extradata[OPUS_HEAD_SIZE + 0];
libavcodec/libopusdec.c:        nb_coupled = avc->extradata[OPUS_HEAD_SIZE + 1];
libavcodec/libopusdec.c:        mapping = avc->extradata + OPUS_HEAD_SIZE + 2;
libavcodec/cook_parser.c: * Determines subpacket duration from extradata.
libavcodec/cook_parser.c:                avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)
libavcodec/cook_parser.c:        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;
libavcodec/av1_parser.c:    int parsed_extradata;
libavcodec/av1_parser.c:    if (avctx->extradata_size && !s->parsed_extradata) {
libavcodec/av1_parser.c:        s->parsed_extradata = 1;
libavcodec/av1_parser.c:        ret = ff_cbs_read_extradata_from_codec(s->cbc, td, avctx);
libavcodec/av1_parser.c:            av_log(avctx, AV_LOG_WARNING, "Failed to parse extradata.\n");
libavcodec/h263dec.c:        if (avctx->extradata_size == 56 && avctx->extradata[0] == 1)
libavcodec/h263dec.c:        if (s->avctx->extradata_size && s->picture_number == 0) {
libavcodec/h263dec.c:            if (init_get_bits8(&gb, s->avctx->extradata, s->avctx->extradata_size) >= 0 )
libavcodec/apedec.c:    if (avctx->extradata_size != 6) {
libavcodec/apedec.c:        av_log(avctx, AV_LOG_ERROR, "Incorrect extradata\n");
libavcodec/apedec.c:    s->fileversion       = AV_RL16(avctx->extradata);
libavcodec/apedec.c:    s->compression_level = AV_RL16(avctx->extradata + 2);
libavcodec/apedec.c:    s->flags             = AV_RL16(avctx->extradata + 4);
libavcodec/libxavs.c:    av_freep(&avctx->extradata);
libavcodec/libxavs.c:        avctx->extradata = p = av_malloc(s);
libavcodec/libxavs.c:            /* Don't put the SEI in extradata. */
libavcodec/libxavs.c:        avctx->extradata_size = p - avctx->extradata;
libavcodec/xiph.h: * Split a single extradata buffer into the three headers that most
libavcodec/xiph.h: * @param[in] extradata The single chunk that combines all three headers
libavcodec/xiph.h: * @param[in] extradata_size The size of the extradata buffer
libavcodec/xiph.h:int avpriv_split_xiph_headers(const uint8_t *extradata, int extradata_size,
libavcodec/h264_slice.c:    // extradata/NAL handling
libavcodec/alacenc.c:    uint8_t *alac_extradata;
libavcodec/alacenc.c:    avctx->extradata = av_mallocz(ALAC_EXTRADATA_SIZE + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/alacenc.c:    if (!avctx->extradata)
libavcodec/alacenc.c:    avctx->extradata_size = ALAC_EXTRADATA_SIZE;
libavcodec/alacenc.c:    alac_extradata = avctx->extradata;
libavcodec/alacenc.c:    AV_WB32(alac_extradata,    ALAC_EXTRADATA_SIZE);
libavcodec/alacenc.c:    AV_WB32(alac_extradata+4,  MKBETAG('a','l','a','c'));
libavcodec/alacenc.c:    AV_WB32(alac_extradata+12, avctx->frame_size);
libavcodec/alacenc.c:    AV_WB8 (alac_extradata+17, avctx->bits_per_raw_sample);
libavcodec/alacenc.c:    AV_WB8 (alac_extradata+21, avctx->channels);
libavcodec/alacenc.c:    AV_WB32(alac_extradata+24, s->max_coded_frame_size);
libavcodec/alacenc.c:    AV_WB32(alac_extradata+28,
libavcodec/alacenc.c:    AV_WB32(alac_extradata+32, avctx->sample_rate);
libavcodec/alacenc.c:    // Set relevant extradata fields
libavcodec/alacenc.c:        AV_WB8(alac_extradata+18, s->rc.history_mult);
libavcodec/alacenc.c:        AV_WB8(alac_extradata+19, s->rc.initial_history);
libavcodec/alacenc.c:        AV_WB8(alac_extradata+20, s->rc.k_modifier);
libavcodec/alac.c: * passed through the extradata[_size] fields. This atom is tacked onto
libavcodec/alac.c:    bytestream2_init(&gb, alac->avctx->extradata,
libavcodec/alac.c:                     alac->avctx->extradata_size);
libavcodec/alac.c:    /* initialize from the extradata */
libavcodec/alac.c:    if (alac->avctx->extradata_size < ALAC_EXTRADATA_SIZE) {
libavcodec/alac.c:        av_log(avctx, AV_LOG_ERROR, "extradata is too small\n");
libavcodec/lcldec.c:    if (avctx->extradata_size < 8) {
libavcodec/lcldec.c:    if ((avctx->codec_id == AV_CODEC_ID_MSZH  && avctx->extradata[7] != CODEC_MSZH) ||
libavcodec/lcldec.c:        (avctx->codec_id == AV_CODEC_ID_ZLIB  && avctx->extradata[7] != CODEC_ZLIB)) {
libavcodec/lcldec.c:    switch (c->imgtype = avctx->extradata[4]) {
libavcodec/lcldec.c:    c->compression = (int8_t)avctx->extradata[5];
libavcodec/lcldec.c:    c->flags = avctx->extradata[6];
libavcodec/aacdec.c:    int initialized;        ///< initialized after a valid extradata was seen
libavcodec/aacdec.c:        if (avctx->extradata_size < esize) {
libavcodec/aacdec.c:            av_free(avctx->extradata);
libavcodec/aacdec.c:            avctx->extradata = av_malloc(esize + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/aacdec.c:            if (!avctx->extradata)
libavcodec/aacdec.c:        avctx->extradata_size = esize;
libavcodec/aacdec.c:          avctx->extradata[i] = get_bits(&gbc, 8);
libavcodec/aacdec.c:        memset(avctx->extradata+esize, 0, AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/aacdec.c:    } else if (!latmctx->aac_ctx.avctx->extradata) {
libavcodec/aacdec.c:        if (!avctx->extradata) {
libavcodec/aacdec.c:                    avctx->extradata, avctx->extradata_size*8LL, 1)) < 0) {
libavcodec/aacdec.c:    if (avctx->extradata_size > 0)
libavcodec/mpegvideo_enc.c:    av_freep(&avctx->extradata);
libavcodec/mpc7.c:    if(avctx->extradata_size < 16){
libavcodec/mpc7.c:        av_log(avctx, AV_LOG_ERROR, "Too small extradata size (%i)!\n", avctx->extradata_size);
libavcodec/mpc7.c:    c->bdsp.bswap_buf((uint32_t *) buf, (const uint32_t *) avctx->extradata, 4);
libavcodec/vorbisenc.c:    av_freep(&avctx->extradata);
libavcodec/vorbisenc.c:    if ((ret = put_main_header(venc, (uint8_t**)&avctx->extradata)) < 0)
libavcodec/vorbisenc.c:    avctx->extradata_size = ret;
libavcodec/a64multienc.c:    /* set up extradata */
libavcodec/a64multienc.c:    if (!(avctx->extradata = av_mallocz(8 * 4 + AV_INPUT_BUFFER_PADDING_SIZE))) {
libavcodec/a64multienc.c:        av_log(avctx, AV_LOG_ERROR, "Failed to allocate memory for extradata.\n");
libavcodec/a64multienc.c:    avctx->extradata_size = 8 * 4;
libavcodec/a64multienc.c:    AV_WB32(avctx->extradata, c->mc_lifetime);
libavcodec/a64multienc.c:    AV_WB32(avctx->extradata + 16, INTERLACED);
libavcodec/a64multienc.c:        AV_WB32(avctx->extradata + 4,  c->mc_frame_counter);
libavcodec/a64multienc.c:        AV_WB32(avctx->extradata + 8,  charset_size);
libavcodec/a64multienc.c:        AV_WB32(avctx->extradata + 12, screen_size + colram_size);
libavcodec/audiotoolboxenc.c:                                       &avctx->extradata_size, NULL) &&
libavcodec/audiotoolboxenc.c:        avctx->extradata_size) {
libavcodec/audiotoolboxenc.c:        int extradata_size = avctx->extradata_size;
libavcodec/audiotoolboxenc.c:        uint8_t *extradata;
libavcodec/audiotoolboxenc.c:        if (!(avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE)))
libavcodec/audiotoolboxenc.c:            avctx->extradata_size = 0x24;
libavcodec/audiotoolboxenc.c:            AV_WB32(avctx->extradata,     0x24);
libavcodec/audiotoolboxenc.c:            AV_WB32(avctx->extradata + 4, MKBETAG('a','l','a','c'));
libavcodec/audiotoolboxenc.c:            extradata = avctx->extradata + 12;
libavcodec/audiotoolboxenc.c:            avctx->extradata_size = 0x24;
libavcodec/audiotoolboxenc.c:            extradata = avctx->extradata;
libavcodec/audiotoolboxenc.c:                                           &extradata_size, extradata);
libavcodec/audiotoolboxenc.c:            bytestream2_init(&gb, extradata, extradata_size);
libavcodec/audiotoolboxenc.c:                        memmove(extradata, gb.buffer, len);
libavcodec/audiotoolboxenc.c:                        avctx->extradata_size = len;
libavcodec/audiotoolboxenc.c:            avctx->extradata_size = extradata_size;
libavcodec/bfi.c:        if (avctx->extradata_size > 768) {
libavcodec/bfi.c:        for (i = 0; i < avctx->extradata_size / 3; i++) {
libavcodec/bfi.c:                *pal += ((avctx->extradata[i * 3 + j] << 2) |
libavcodec/bfi.c:                         (avctx->extradata[i * 3 + j] >> 4)) << shift;
libavcodec/h264dec.c:        if (avctx->extradata_size > 0 && avctx->extradata) {
libavcodec/h264dec.c:            ret = ff_h264_decode_extradata(avctx->extradata, avctx->extradata_size,
libavcodec/h264dec.c:                      "Error decoding the extradata\n");
libavcodec/h264dec.c:static int is_avcc_extradata(const uint8_t *buf, int buf_size)
libavcodec/h264dec.c:        ff_h264_decode_extradata(side, side_size,
libavcodec/h264dec.c:        if (is_avcc_extradata(buf, buf_size))
libavcodec/h264dec.c:            return ff_h264_decode_extradata(buf, buf_size,
libavcodec/vp3.c:     * otherwise. The 32 different tokens with up to 12 bits of extradata are
libavcodec/vp3.c:    if (!avctx->extradata_size) {
libavcodec/vp3.c:        av_log(avctx, AV_LOG_ERROR, "Missing extradata!\n");
libavcodec/vp3.c:    if (avpriv_split_xiph_headers(avctx->extradata, avctx->extradata_size,
libavcodec/vp3.c:        av_log(avctx, AV_LOG_ERROR, "Corrupt extradata\n");
libavcodec/vp3.c:            av_log(avctx, AV_LOG_ERROR, "Invalid extradata!\n");
libavcodec/aasc.c:        ptr = avctx->extradata;
libavcodec/aasc.c:        s->palette_size = FFMIN(avctx->extradata_size, AVPALETTE_SIZE);
libavcodec/remove_extradata_bsf.c:static int remove_extradata(AVBSFContext *ctx, AVPacket *pkt)
libavcodec/remove_extradata_bsf.c:static int remove_extradata_init(AVBSFContext *ctx)
libavcodec/remove_extradata_bsf.c:static void remove_extradata_close(AVBSFContext *ctx)
libavcodec/remove_extradata_bsf.c:static const AVClass remove_extradata_class = {
libavcodec/remove_extradata_bsf.c:    .class_name = "remove_extradata",
libavcodec/remove_extradata_bsf.c:const AVBitStreamFilter ff_remove_extradata_bsf = {
libavcodec/remove_extradata_bsf.c:    .priv_class     = &remove_extradata_class,
libavcodec/remove_extradata_bsf.c:    .init           = remove_extradata_init,
libavcodec/remove_extradata_bsf.c:    .close          = remove_extradata_close,
libavcodec/remove_extradata_bsf.c:    .filter         = remove_extradata,
libavcodec/mpeg4audio.h: * Parse MPEG-4 systems extradata from a potentially unaligned GetBitContext to retrieve audio configuration.
libavcodec/mpeg4audio.h: * @return negative AVERROR code on error, on success AudioSpecificConfig bit index in extradata.
libavcodec/mpeg4audio.h: * Parse MPEG-4 systems extradata from a raw buffer to retrieve audio configuration.
libavcodec/mpeg4audio.h: * @return negative AVERROR code on error, on success AudioSpecificConfig bit index in extradata.
libavcodec/mpeg4audio.h: * Parse MPEG-4 systems extradata from a raw buffer to retrieve audio configuration.
libavcodec/mpeg4audio.h: * @return negative AVERROR code on error, AudioSpecificConfig bit index in extradata on success.
libavcodec/cbs_av1.c:        // first bit is nonzero, the extradata does not consist purely of
libavcodec/clearvideo.c:    if (avctx->extradata_size == 110) {
libavcodec/clearvideo.c:        c->tile_size = AV_RL32(&avctx->extradata[94]);
libavcodec/clearvideo.c:    } else if (avctx->extradata_size == 150) {
libavcodec/clearvideo.c:        c->tile_size = AV_RB32(&avctx->extradata[134]);
libavcodec/clearvideo.c:    } else if (!avctx->extradata_size) {
libavcodec/clearvideo.c:        av_log(avctx, AV_LOG_ERROR, "Unsupported extradata size: %d\n", avctx->extradata_size);
libavcodec/h264_parse.c:static int decode_extradata_ps(const uint8_t *data, int size, H264ParamSets *ps,
libavcodec/h264_parse.c:            av_log(logctx, AV_LOG_VERBOSE, "Ignoring NAL type %d in extradata\n",
libavcodec/h264_parse.c:/* There are (invalid) samples in the wild with mp4-style extradata, where the
libavcodec/h264_parse.c:static int decode_extradata_ps_mp4(const uint8_t *buf, int buf_size, H264ParamSets *ps,
libavcodec/h264_parse.c:    ret = decode_extradata_ps(buf, buf_size, ps, 1, logctx);
libavcodec/h264_parse.c:        (void)decode_extradata_ps(escaped_buf, escaped_buf_size, ps, 1, logctx);
libavcodec/h264_parse.c:        // lorex.mp4 decodes ok even with extradata decoding failing
libavcodec/h264_parse.c:int ff_h264_decode_extradata(const uint8_t *data, int size, H264ParamSets *ps,
libavcodec/h264_parse.c:            ret = decode_extradata_ps_mp4(p, nalsize, ps, err_recognition, logctx);
libavcodec/h264_parse.c:            ret = decode_extradata_ps_mp4(p, nalsize, ps, err_recognition, logctx);
libavcodec/h264_parse.c:        ret = decode_extradata_ps(data, size, ps, 0, logctx);
libavcodec/hnm4video.c:    if (avctx->extradata_size < 1) {
libavcodec/hnm4video.c:    hnm->version   = avctx->extradata[0];
libavcodec/flac.c:int ff_flac_is_extradata_valid(AVCodecContext *avctx,
libavcodec/flac.c:    if (!avctx->extradata || avctx->extradata_size < FLAC_STREAMINFO_SIZE) {
libavcodec/flac.c:        av_log(avctx, AV_LOG_ERROR, "extradata NULL or too small.\n");
libavcodec/flac.c:    if (AV_RL32(avctx->extradata) != MKTAG('f','L','a','C')) {
libavcodec/flac.c:        /* extradata contains STREAMINFO only */
libavcodec/flac.c:        if (avctx->extradata_size != FLAC_STREAMINFO_SIZE) {
libavcodec/flac.c:            av_log(avctx, AV_LOG_WARNING, "extradata contains %d bytes too many.\n",
libavcodec/flac.c:                   FLAC_STREAMINFO_SIZE-avctx->extradata_size);
libavcodec/flac.c:        *streaminfo_start = avctx->extradata;
libavcodec/flac.c:        if (avctx->extradata_size < 8+FLAC_STREAMINFO_SIZE) {
libavcodec/flac.c:            av_log(avctx, AV_LOG_ERROR, "extradata too small.\n");
libavcodec/flac.c:        *streaminfo_start = &avctx->extradata[8];
libavcodec/mpeg4video_parser.c:    if (avctx->extradata_size && pc->first_picture) {
libavcodec/mpeg4video_parser.c:        init_get_bits(gb, avctx->extradata, avctx->extradata_size * 8);
libavcodec/mpeg4video_parser.c:            av_log(avctx, AV_LOG_WARNING, "Failed to parse extradata\n");
libavcodec/librav1e.c:         const AVBitStreamFilter *filter = av_bsf_get_by_name("extract_extradata");
libavcodec/librav1e.c:            av_log(avctx, AV_LOG_ERROR, "extract_extradata bitstream filter "
libavcodec/librav1e.c:            av_log(avctx, AV_LOG_ERROR, "extradata extraction send failed.\n");
libavcodec/librav1e.c:            av_log(avctx, AV_LOG_ERROR, "extradata extraction receive failed.\n");
libavcodec/mpc8.c:    if(avctx->extradata_size < 2){
libavcodec/mpc8.c:        av_log(avctx, AV_LOG_ERROR, "Too small extradata size (%i)!\n", avctx->extradata_size);
libavcodec/mpc8.c:    init_get_bits(&gb, avctx->extradata, 16);
libavcodec/ffv1enc.c:static int write_extradata(FFV1Context *f)
libavcodec/ffv1enc.c:    f->avctx->extradata_size = 10000 + 4 +
libavcodec/ffv1enc.c:    f->avctx->extradata = av_malloc(f->avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/ffv1enc.c:    if (!f->avctx->extradata)
libavcodec/ffv1enc.c:    ff_init_range_encoder(c, f->avctx->extradata, f->avctx->extradata_size);
libavcodec/ffv1enc.c:    f->avctx->extradata_size = ff_rac_terminate(c, 0);
libavcodec/ffv1enc.c:    v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, f->avctx->extradata, f->avctx->extradata_size);
libavcodec/ffv1enc.c:    AV_WL32(f->avctx->extradata + f->avctx->extradata_size, v);
libavcodec/ffv1enc.c:    f->avctx->extradata_size += 4;
libavcodec/ffv1enc.c:        if ((ret = write_extradata(s)) < 0)
libavcodec/yop.c:    if (avctx->extradata_size < 3) {
libavcodec/yop.c:        av_log(avctx, AV_LOG_ERROR, "Missing or incomplete extradata.\n");
libavcodec/yop.c:    s->num_pal_colors = avctx->extradata[0];
libavcodec/yop.c:    s->first_color[0] = avctx->extradata[1];
libavcodec/yop.c:    s->first_color[1] = avctx->extradata[2];
libavcodec/vc1dec.c:    if (!avctx->extradata_size || !avctx->extradata)
libavcodec/vc1dec.c:        // looks like WMV3 has a sequence header stored in the extradata
libavcodec/vc1dec.c:        // the last byte of the extradata is a version number, 1 for the
libavcodec/vc1dec.c:        init_get_bits(&gb, avctx->extradata, avctx->extradata_size*8);
libavcodec/vc1dec.c:        count = avctx->extradata_size*8 - get_bits_count(&gb);
libavcodec/vc1dec.c:        const uint8_t *start = avctx->extradata;
libavcodec/vc1dec.c:        uint8_t *end = avctx->extradata + avctx->extradata_size;
libavcodec/vc1dec.c:        if (avctx->extradata_size < 16) {
libavcodec/vc1dec.c:            av_log(avctx, AV_LOG_ERROR, "Extradata size too small: %i\n", avctx->extradata_size);
libavcodec/vc1dec.c:        buf2  = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/vc1dec.c:        start = find_next_marker(start, end); // in WVC1 extradata first byte is its size, but can be 0 in mkv
libavcodec/vc1dec.c:            av_log(avctx, AV_LOG_ERROR, "Incomplete extradata\n");
libavcodec/libspeexenc.c:    /* allocate extradata */
libavcodec/libspeexenc.c:    avctx->extradata = av_malloc(header_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/libspeexenc.c:    if (!avctx->extradata) {
libavcodec/libspeexenc.c:    /* copy header packet to extradata */
libavcodec/libspeexenc.c:    memcpy(avctx->extradata, header_data, header_size);
libavcodec/libspeexenc.c:    avctx->extradata_size = header_size;
libavcodec/libspeexenc.c:    av_freep(&avctx->extradata);
libavcodec/cbs_bsf.c:               "Failed to read extradata from packet side data.\n");
libavcodec/cbs_bsf.c:               "Failed to write extradata into packet side data.\n");
libavcodec/cbs_bsf.c:    if (bsf->par_in->extradata) {
libavcodec/cbs_bsf.c:        err = ff_cbs_read_extradata(ctx->input, frag, bsf->par_in);
libavcodec/cbs_bsf.c:            av_log(bsf, AV_LOG_ERROR, "Failed to read extradata.\n");
libavcodec/cbs_bsf.c:        err = ff_cbs_write_extradata(ctx->output, bsf->par_out, frag);
libavcodec/cbs_bsf.c:            av_log(bsf, AV_LOG_ERROR, "Failed to write extradata.\n");
libavcodec/rawdec.c:    if ((avctx->extradata_size >= 9 &&
libavcodec/rawdec.c:         !memcmp(avctx->extradata + avctx->extradata_size - 9, "BottomUp", 9)) ||
libavcodec/libvorbisenc.c:    av_freep(&avctx->extradata);
libavcodec/libvorbisenc.c:    avctx->extradata_size = 1 + xiph_len(header.bytes)      +
libavcodec/libvorbisenc.c:    p = avctx->extradata = av_malloc(avctx->extradata_size +
libavcodec/libvorbisenc.c:    av_assert0(offset == avctx->extradata_size);
libavcodec/libvorbisenc.c:    s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);
libavcodec/libvorbisenc.c:        av_log(avctx, AV_LOG_ERROR, "invalid extradata\n");
libavcodec/opus_metadata_bsf.c:    if (bsfc->par_out->extradata_size < 19)
libavcodec/opus_metadata_bsf.c:    AV_WL16(bsfc->par_out->extradata + 16, s->gain);
libavcodec/remove_extradata_bsf.d:libavcodec/remove_extradata_bsf.o: libavcodec/remove_extradata_bsf.c \
libavcodec/ffv1dec.c:    ff_init_range_decoder(c, f->avctx->extradata, f->avctx->extradata_size);
libavcodec/ffv1dec.c:                   f->avctx->extradata, f->avctx->extradata_size);
libavcodec/ffv1dec.c:        if (v || f->avctx->extradata_size < 4) {
libavcodec/ffv1dec.c:        crc = AV_RB32(f->avctx->extradata + f->avctx->extradata_size - 4);
libavcodec/ffv1dec.c:    if (avctx->extradata_size > 0 && (ret = read_extra_header(f)) < 0)
libavcodec/kmvc.c:    if (avctx->extradata_size < 12) {
libavcodec/kmvc.c:        c->palsize = AV_RL16(avctx->extradata + 10);
libavcodec/kmvc.c:    if (avctx->extradata_size == 1036) {        // palette in extradata
libavcodec/kmvc.c:        uint8_t *src = avctx->extradata + 12;
libavcodec/opusdec.c:    ret = ff_opus_parse_extradata(avctx, c);
libavcodec/r210dec.c:             avctx->extradata_size >= 12 && !memcmp(&avctx->extradata[4], "DpxE", 4) &&
libavcodec/r210dec.c:             !avctx->extradata[11];
libavcodec/interplayacm.c:    if (avctx->extradata_size < 14)
libavcodec/interplayacm.c:    s->level = AV_RL16(avctx->extradata + 12) & 0xf;
libavcodec/interplayacm.c:    s->rows  = AV_RL16(avctx->extradata + 12) >>  4;
libavcodec/bink.c:    if (avctx->extradata_size < 4) {
libavcodec/bink.c:    flags = AV_RL32(avctx->extradata);
libavcodec/mfenc.c:            avctx->extradata = av_mallocz(sz + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/mfenc.c:            if (!avctx->extradata)
libavcodec/mfenc.c:            avctx->extradata_size = sz;
libavcodec/mfenc.c:            hr = IMFAttributes_GetBlob(type, &MF_MT_USER_DATA, avctx->extradata, sz, NULL);
libavcodec/mfenc.c:            if (avctx->codec_id == AV_CODEC_ID_AAC && avctx->extradata_size >= 12) {
libavcodec/mfenc.c:                avctx->extradata_size = avctx->extradata_size - 12;
libavcodec/mfenc.c:                memmove(avctx->extradata, avctx->extradata + 12, avctx->extradata_size);
libavcodec/mfenc.c:        uint8_t *extradata = av_mallocz(sz + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/mfenc.c:        if (!extradata)
libavcodec/mfenc.c:        hr = IMFAttributes_GetBlob(type, &MF_MT_MPEG_SEQUENCE_HEADER, extradata, sz, NULL);
libavcodec/mfenc.c:            av_free(extradata);
libavcodec/mfenc.c:        av_freep(&avctx->extradata);
libavcodec/mfenc.c:        avctx->extradata = extradata;
libavcodec/mfenc.c:        avctx->extradata_size = sz;
libavcodec/mfenc.c:        c->is_video && !avctx->extradata) {
libavcodec/mfenc.c:        av_log(avctx, AV_LOG_VERBOSE, "Awaiting extradata\n");
libavcodec/mfenc.c:            // The Qualcomm H264 encoder on SD835 doesn't provide extradata
libavcodec/mfenc.c:            // of the QSV H264 encoder at least) don't provide extradata this
libavcodec/mfenc.c:            if (avctx->extradata)
libavcodec/mfenc.c:        av_log(avctx, AV_LOG_VERBOSE, "%s extradata in %d ms\n",
libavcodec/mfenc.c:               avctx->extradata ? "Got" : "Didn't get", total / 1000);
libavcodec/mfenc.c:    av_freep(&avctx->extradata);
libavcodec/mfenc.c:    avctx->extradata_size = 0;
libavcodec/wmalosslessdec.c:    uint8_t *edata_ptr = avctx->extradata;
libavcodec/wmalosslessdec.c:    if (avctx->extradata_size >= 18) {
libavcodec/wmalosslessdec.c:        /* dump the extradata */
libavcodec/wmalosslessdec.c:        for (i = 0; i < avctx->extradata_size; i++)
libavcodec/wmalosslessdec.c:            ff_dlog(avctx, "[%x] ", avctx->extradata[i]);
libavcodec/wmalosslessdec.c:        avpriv_request_sample(avctx, "Unsupported extradata size");
libavcodec/idcinvideo.c: * transmit the 65536-byte Huffman table(s) to the decoder via extradata.
libavcodec/idcinvideo.c: * the demuxer must use the same extradata space to transmit an
libavcodec/idcinvideo.c:    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {
libavcodec/idcinvideo.c:        av_log(s->avctx, AV_LOG_ERROR, "  id CIN video: expected extradata size of %d\n", HUFFMAN_TABLE_SIZE);
libavcodec/idcinvideo.c:    histograms = (unsigned char *)s->avctx->extradata;
libavcodec/pngdec.c:        if (!avctx->extradata_size)
libavcodec/pngdec.c:        /* only init fields, there is no zlib use in extradata */
libavcodec/pngdec.c:        bytestream2_init(&s->gb, avctx->extradata, avctx->extradata_size);
libavcodec/mp3_header_decompress_bsf.c:    if(ctx->par_in->extradata_size != 15 || strcmp(ctx->par_in->extradata, "FFCMP3 0.0")){
libavcodec/mp3_header_decompress_bsf.c:        av_log(ctx, AV_LOG_ERROR, "Extradata invalid %d\n", ctx->par_in->extradata_size);
libavcodec/mp3_header_decompress_bsf.c:    header= AV_RB32(ctx->par_in->extradata+11) & MP3_MASK;
libavcodec/adxdec.c:    if (avctx->extradata_size >= 24) {
libavcodec/adxdec.c:        if ((ret = ff_adx_decode_header(avctx, avctx->extradata,
libavcodec/adxdec.c:                                        avctx->extradata_size, &header_size,
libavcodec/adxdec.c:    buffer_size_t new_extradata_size;
libavcodec/adxdec.c:    uint8_t *new_extradata;
libavcodec/adxdec.c:    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,
libavcodec/adxdec.c:                                            &new_extradata_size);
libavcodec/adxdec.c:    if (new_extradata && new_extradata_size > 0) {
libavcodec/adxdec.c:        if ((ret = ff_adx_decode_header(avctx, new_extradata,
libavcodec/adxdec.c:                                        new_extradata_size, &header_size,
libavcodec/adxdec.c:            av_log(avctx, AV_LOG_ERROR, "error parsing new ADX extradata\n");
libavcodec/atrac9dec.c:    if (avctx->extradata_size != 12) {
libavcodec/atrac9dec.c:        av_log(avctx, AV_LOG_ERROR, "Invalid extradata length!\n");
libavcodec/atrac9dec.c:    version = AV_RL32(avctx->extradata);
libavcodec/atrac9dec.c:    init_get_bits8(&gb, avctx->extradata + 4, avctx->extradata_size);
libavcodec/assenc.c:    avctx->extradata = av_malloc(avctx->subtitle_header_size + 1);
libavcodec/assenc.c:    if (!avctx->extradata)
libavcodec/assenc.c:    memcpy(avctx->extradata, avctx->subtitle_header, avctx->subtitle_header_size);
libavcodec/assenc.c:    avctx->extradata_size = avctx->subtitle_header_size;
libavcodec/assenc.c:    avctx->extradata[avctx->extradata_size] = 0;
libavcodec/metasound.c:    if (!avctx->extradata || avctx->extradata_size < 16) {
libavcodec/metasound.c:        av_log(avctx, AV_LOG_ERROR, "Missing or incomplete extradata\n");
libavcodec/metasound.c:    tag = AV_RL32(avctx->extradata + 12);
libavcodec/libfdk-aacdec.c:    s->handle = aacDecoder_Open(avctx->extradata_size ? TT_MP4_RAW : TT_MP4_ADTS, 1);
libavcodec/libfdk-aacdec.c:    if (avctx->extradata_size) {
libavcodec/libfdk-aacdec.c:        if ((err = aacDecoder_ConfigRaw(s->handle, &avctx->extradata,
libavcodec/libfdk-aacdec.c:                                        &avctx->extradata_size)) != AAC_DEC_OK) {
libavcodec/libfdk-aacdec.c:            av_log(avctx, AV_LOG_ERROR, "Unable to set extradata\n");
libavcodec/options_table.h:{"global_header", "place global headers in extradata instead of every keyframe", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_GLOBAL_HEADER }, INT_MIN, INT_MAX, V|A|E, "flags"},
libavcodec/options_table.h:{"local_header", "place global headers at every keyframe instead of in extradata", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_LOCAL_HEADER }, INT_MIN, INT_MAX, V|E, "flags2"},
libavcodec/libkvazaar.c:        avctx->extradata = p = av_mallocz(len_out + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/libkvazaar.c:        avctx->extradata_size = len_out;
libavcodec/libkvazaar.c:    if (avctx->extradata)
libavcodec/libkvazaar.c:        av_freep(&avctx->extradata);
libavcodec/libtheoraenc.c:/** Concatenate an ogg_packet into the extradata. */
libavcodec/libtheoraenc.c:    int newsize = avc_context->extradata_size + 2 + packet->bytes;
libavcodec/libtheoraenc.c:    } else if (newsize < avc_context->extradata_size) {
libavcodec/libtheoraenc.c:        message = "extradata_size would overflow";
libavcodec/libtheoraenc.c:        if ((err = av_reallocp(&avc_context->extradata, newsize)) < 0) {
libavcodec/libtheoraenc.c:            avc_context->extradata_size = 0;
libavcodec/libtheoraenc.c:    avc_context->extradata_size = newsize;
libavcodec/libtheoraenc.c:    AV_WB16(avc_context->extradata + (*offset), packet->bytes);
libavcodec/libtheoraenc.c:    memcpy(avc_context->extradata + (*offset), packet->packet, packet->bytes);
libavcodec/libtheoraenc.c:        are concatenated together into libavcodec's extradata.
libavcodec/libtheoraenc.c:    av_freep(&avc_context->extradata);
libavcodec/libtheoraenc.c:    avc_context->extradata_size = 0;
libavcodec/vp6.c: * The VP6F decoder accepts an optional 1 byte extradata. It is composed of:
libavcodec/vp6.c:            if (s->avctx->extradata_size == 0 &&
libavcodec/vp6.c:                if (s->avctx->extradata_size == 1) {
libavcodec/vp6.c:                    s->avctx->width  -= s->avctx->extradata[0] >> 4;
libavcodec/vp6.c:                    s->avctx->height -= s->avctx->extradata[0] & 0x0F;
libavcodec/hevc_parser.c:    int parsed_extradata;
libavcodec/hevc_parser.c:    if (avctx->extradata && !ctx->parsed_extradata) {
libavcodec/hevc_parser.c:        ff_hevc_decode_extradata(avctx->extradata, avctx->extradata_size, &ctx->ps, &ctx->sei,
libavcodec/hevc_parser.c:        ctx->parsed_extradata = 1;
libavcodec/libxvid.c:        if (!avctx->extradata) {
libavcodec/libxvid.c:            avctx->extradata = av_malloc(vo_len);
libavcodec/libxvid.c:            if (!avctx->extradata)
libavcodec/libxvid.c:            memcpy(avctx->extradata, pkt->data, vo_len);
libavcodec/libxvid.c:            avctx->extradata_size = vo_len;
libavcodec/libxvid.c:    avctx->extradata      = NULL;
libavcodec/libxvid.c:    avctx->extradata_size = 0;
libavcodec/libxvid.c:    /* Encode a dummy frame to get the extradata immediately */
libavcodec/libxvid.c:    av_freep(&avctx->extradata);
libavcodec/vqavideo.c: * of the VQA file passed through the extradata field. The VQHD header
libavcodec/vqavideo.c:    /* make sure the extradata made it */
libavcodec/vqavideo.c:    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {
libavcodec/vqavideo.c:        av_log(s->avctx, AV_LOG_ERROR, "expected extradata size of %d\n", VQA_HEADER_SIZE);
libavcodec/vqavideo.c:    s->vqa_version = s->avctx->extradata[0];
libavcodec/vqavideo.c:    s->width = AV_RL16(&s->avctx->extradata[6]);
libavcodec/vqavideo.c:    s->height = AV_RL16(&s->avctx->extradata[8]);
libavcodec/vqavideo.c:    s->vector_width = s->avctx->extradata[10];
libavcodec/vqavideo.c:    s->vector_height = s->avctx->extradata[11];
libavcodec/vqavideo.c:    s->partial_count = s->partial_countdown = s->avctx->extradata[13];
libavcodec/svq3.c: * via the AVCodecContext's extradata[_size] field:
libavcodec/svq3.c: * AVCodecContext.extradata = pointer to ImageDescription, first characters
libavcodec/svq3.c: * AVCodecContext.extradata_size = size of ImageDescription atom memory
libavcodec/svq3.c:    unsigned char *extradata;
libavcodec/svq3.c:    unsigned char *extradata_end;
libavcodec/svq3.c:    /* prowl for the "SEQH" marker in the extradata */
libavcodec/svq3.c:    extradata     = (unsigned char *)avctx->extradata;
libavcodec/svq3.c:    extradata_end = avctx->extradata + avctx->extradata_size;
libavcodec/svq3.c:    if (extradata) {
libavcodec/svq3.c:        for (m = 0; m + 8 < avctx->extradata_size; m++) {
libavcodec/svq3.c:            if (!memcmp(extradata, "SEQH", 4)) {
libavcodec/svq3.c:            extradata++;
libavcodec/svq3.c:        size = AV_RB32(&extradata[4]);
libavcodec/svq3.c:        if (size > extradata_end - extradata - 8)
libavcodec/svq3.c:        init_get_bits(&gb, extradata + 8, size * 8);
libavcodec/svq3.c:            if (uncompress(buf, &buf_len, extradata + 8 + offset,
libavcodec/mpeg4_unpack_bframes_bsf.c:    if (ctx->par_in->extradata) {
libavcodec/mpeg4_unpack_bframes_bsf.c:        scan_buffer(ctx->par_in->extradata, ctx->par_in->extradata_size, &pos_p_ext, NULL, NULL);
libavcodec/mpeg4_unpack_bframes_bsf.c:                   "Updating DivX userdata (remove trailing 'p') in extradata.\n");
libavcodec/mpeg4_unpack_bframes_bsf.c:            ctx->par_out->extradata[pos_p_ext] = '\0';
libavcodec/huffyuvdec.c:    if (avctx->extradata_size) {
libavcodec/huffyuvdec.c:        else if (avctx->extradata_size > 3 && avctx->extradata[3] == 0)
libavcodec/huffyuvdec.c:        if (avctx->extradata_size < 4)
libavcodec/huffyuvdec.c:        method           = avctx->extradata[0];
libavcodec/huffyuvdec.c:            s->bitstream_bpp = avctx->extradata[1];
libavcodec/huffyuvdec.c:            s->bps = (avctx->extradata[1] >> 4) + 1;
libavcodec/huffyuvdec.c:            s->chroma_h_shift = avctx->extradata[1] & 3;
libavcodec/huffyuvdec.c:            s->chroma_v_shift = (avctx->extradata[1] >> 2) & 3;
libavcodec/huffyuvdec.c:            s->yuv   = !!(avctx->extradata[2] & 1);
libavcodec/huffyuvdec.c:            s->chroma= !!(avctx->extradata[2] & 3);
libavcodec/huffyuvdec.c:            s->alpha = !!(avctx->extradata[2] & 4);
libavcodec/huffyuvdec.c:        interlace     = (avctx->extradata[2] & 0x30) >> 4;
libavcodec/huffyuvdec.c:        s->context    = avctx->extradata[2] & 0x40 ? 1 : 0;
libavcodec/huffyuvdec.c:        if ((ret = read_huffman_tables(s, avctx->extradata + 4,
libavcodec/huffyuvdec.c:                                       avctx->extradata_size - 4)) < 0)
libavcodec/anm.c:    if (avctx->extradata_size < 16 * 8 + 4 * 256)
libavcodec/anm.c:    bytestream2_init(&gb, avctx->extradata, avctx->extradata_size);
libavcodec/dvdsubdec.c:static int dvdsub_parse_extradata(AVCodecContext *avctx)
libavcodec/dvdsubdec.c:    if (!avctx->extradata || !avctx->extradata_size)
libavcodec/dvdsubdec.c:    dataorig = data = av_malloc(avctx->extradata_size+1);
libavcodec/dvdsubdec.c:    memcpy(data, avctx->extradata, avctx->extradata_size);
libavcodec/dvdsubdec.c:    data[avctx->extradata_size] = '\0';
libavcodec/dvdsubdec.c:    if ((ret = dvdsub_parse_extradata(avctx)) < 0)
libavcodec/tta.c:    if (avctx->extradata_size < 22)
libavcodec/tta.c:    ret = init_get_bits8(&gb, avctx->extradata, avctx->extradata_size);
libavcodec/tta.c:        av_log(avctx, AV_LOG_ERROR, "Wrong extradata present\n");
libavcodec/wmaprodec.c: * as extradata that has to be passed to the decoder.
libavcodec/wmaprodec.c:    uint8_t *edata_ptr = avctx->extradata;
libavcodec/wmaprodec.c:    /** dump the extradata */
libavcodec/wmaprodec.c:    av_log(avctx, AV_LOG_DEBUG, "extradata:\n");
libavcodec/wmaprodec.c:    for (i = 0; i < avctx->extradata_size; i++)
libavcodec/wmaprodec.c:        av_log(avctx, AV_LOG_DEBUG, "[%x] ", avctx->extradata[i]);
libavcodec/wmaprodec.c:    if (avctx->codec_id == AV_CODEC_ID_XMA2 && avctx->extradata_size == 34) { /* XMA2WAVEFORMATEX */
libavcodec/wmaprodec.c:    } else if (avctx->codec_id == AV_CODEC_ID_WMAPRO && avctx->extradata_size >= 18) {
libavcodec/wmaprodec.c:        avpriv_request_sample(avctx, "Unknown extradata size");
libavcodec/wmaprodec.c:    if (avctx->channels <= 0 || avctx->extradata_size == 0)
libavcodec/wmaprodec.c:    if (avctx->codec_id == AV_CODEC_ID_XMA2 && avctx->extradata_size == 34) { /* XMA2WAVEFORMATEX */
libavcodec/wmaprodec.c:    } else if (avctx->codec_id == AV_CODEC_ID_XMA2 && avctx->extradata_size >= 2) { /* XMA2WAVEFORMAT */
libavcodec/wmaprodec.c:        s->num_streams = avctx->extradata[1];
libavcodec/wmaprodec.c:        if (avctx->extradata_size != (32 + ((avctx->extradata[0]==3)?0:8) + 4*s->num_streams)) {
libavcodec/wmaprodec.c:            av_log(avctx, AV_LOG_ERROR, "Incorrect XMA2 extradata size\n");
libavcodec/wmaprodec.c:    } else if (avctx->codec_id == AV_CODEC_ID_XMA1 && avctx->extradata_size >= 4) { /* XMAWAVEFORMAT */
libavcodec/wmaprodec.c:        s->num_streams = avctx->extradata[4];
libavcodec/wmaprodec.c:        if (avctx->extradata_size != (8 + 20*s->num_streams)) {
libavcodec/wmaprodec.c:            av_log(avctx, AV_LOG_ERROR, "Incorrect XMA1 extradata size\n");
libavcodec/adpcmenc.c:    uint8_t *extradata;
libavcodec/adpcmenc.c:        if (!(avctx->extradata = av_malloc(32 + AV_INPUT_BUFFER_PADDING_SIZE)))
libavcodec/adpcmenc.c:        avctx->extradata_size = 32;
libavcodec/adpcmenc.c:        extradata = avctx->extradata;
libavcodec/adpcmenc.c:        bytestream_put_le16(&extradata, avctx->frame_size);
libavcodec/adpcmenc.c:        bytestream_put_le16(&extradata, 7); /* wNumCoef */
libavcodec/adpcmenc.c:            bytestream_put_le16(&extradata, ff_adpcm_AdaptCoeff1[i] * 4);
libavcodec/adpcmenc.c:            bytestream_put_le16(&extradata, ff_adpcm_AdaptCoeff2[i] * 4);
libavcodec/adpcmenc.c:        if (!(avctx->extradata = av_mallocz(28 + AV_INPUT_BUFFER_PADDING_SIZE)))
libavcodec/adpcmenc.c:        avctx->extradata_size = 28;
libavcodec/lclenc.c:    avctx->extradata = av_mallocz(8 + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/lclenc.c:    if (!avctx->extradata)
libavcodec/lclenc.c:    avctx->extradata[0]= 4;
libavcodec/lclenc.c:    avctx->extradata[1]= 0;
libavcodec/lclenc.c:    avctx->extradata[2]= 0;
libavcodec/lclenc.c:    avctx->extradata[3]= 0;
libavcodec/lclenc.c:    avctx->extradata[4]= c->imgtype;
libavcodec/lclenc.c:    avctx->extradata[5]= c->compression;
libavcodec/lclenc.c:    avctx->extradata[6]= c->flags;
libavcodec/lclenc.c:    avctx->extradata[7]= CODEC_ZLIB;
libavcodec/lclenc.c:    c->avctx->extradata_size= 8;
libavcodec/lclenc.c:    av_freep(&avctx->extradata);
libavcodec/atrac3.c: * To use this decoder, a calling application must supply the extradata
libavcodec/atrac3.c:    /** extradata */
libavcodec/atrac3.c:    const uint8_t *edata_ptr = avctx->extradata;
libavcodec/atrac3.c:    /* Take care of the codec-specific extradata. */
libavcodec/atrac3.c:    } else if (avctx->extradata_size == 14) {
libavcodec/atrac3.c:        /* Parse the extradata, WAV format */
libavcodec/atrac3.c:    } else if (avctx->extradata_size == 12 || avctx->extradata_size == 10) {
libavcodec/atrac3.c:        /* Parse the extradata, RM format. */
libavcodec/atrac3.c:        av_log(avctx, AV_LOG_ERROR, "Unknown extradata size %d.\n",
libavcodec/atrac3.c:               avctx->extradata_size);
libavcodec/atrac3.c:    /* Check the extradata */
libavcodec/filter_units_bsf.c:    if (bsf->par_in->extradata) {
libavcodec/filter_units_bsf.c:        err = ff_cbs_read_extradata(ctx->cbc, frag, bsf->par_in);
libavcodec/filter_units_bsf.c:            av_log(bsf, AV_LOG_ERROR, "Failed to read extradata.\n");
libavcodec/filter_units_bsf.c:            err = ff_cbs_write_extradata(ctx->cbc, bsf->par_out, frag);
libavcodec/filter_units_bsf.c:                av_log(bsf, AV_LOG_ERROR, "Failed to write extradata.\n");
libavcodec/parser.c:    if (avctx->extradata) {
libavcodec/parser.c:            int size = buf_size + avctx->extradata_size;
libavcodec/parser.c:            memcpy(*poutbuf, avctx->extradata, avctx->extradata_size);
libavcodec/parser.c:            memcpy(*poutbuf + avctx->extradata_size, buf,
libavcodec/bitstream_filter.c:    int extradata_updated;
libavcodec/bitstream_filter.c:    if (!priv->extradata_updated) {
libavcodec/bitstream_filter.c:        /* update extradata in avctx from the output codec parameters */
libavcodec/bitstream_filter.c:        if (priv->ctx->par_out->extradata_size && (!args || !strstr(args, "private_spspps_buf"))) {
libavcodec/bitstream_filter.c:            av_freep(&avctx->extradata);
libavcodec/bitstream_filter.c:            avctx->extradata_size = 0;
libavcodec/bitstream_filter.c:            avctx->extradata = av_mallocz(priv->ctx->par_out->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/bitstream_filter.c:            if (!avctx->extradata)
libavcodec/bitstream_filter.c:            memcpy(avctx->extradata, priv->ctx->par_out->extradata, priv->ctx->par_out->extradata_size);
libavcodec/bitstream_filter.c:            avctx->extradata_size = priv->ctx->par_out->extradata_size;
libavcodec/bitstream_filter.c:        priv->extradata_updated = 1;
libavcodec/wmadec.c: * to the decoder using the extradata[_size] fields in AVCodecContext. There
libavcodec/wmadec.c:    uint8_t *extradata;
libavcodec/wmadec.c:    extradata = avctx->extradata;
libavcodec/wmadec.c:    if (avctx->codec->id == AV_CODEC_ID_WMAV1 && avctx->extradata_size >= 4)
libavcodec/wmadec.c:        flags2 = AV_RL16(extradata + 2);
libavcodec/wmadec.c:    else if (avctx->codec->id == AV_CODEC_ID_WMAV2 && avctx->extradata_size >= 6)
libavcodec/wmadec.c:        flags2 = AV_RL16(extradata + 4);
libavcodec/wmadec.c:    if (avctx->codec->id == AV_CODEC_ID_WMAV2 && avctx->extradata_size >= 8){
libavcodec/wmadec.c:        if (AV_RL16(extradata+4)==0xd && s->use_variable_block_len){
libavcodec/wmavoice.c:     * @name Global values specified in the stream header / extradata or used all over.
libavcodec/wmavoice.c:                                  ///< it contains the extradata from the
libavcodec/wmavoice.c: * Set up the variable bit mode (VBM) tree from container extradata.
libavcodec/wmavoice.c: *           container extradata (i.e. the ones containing the VBM tree).
libavcodec/wmavoice.c: * Set up decoder with parameters from demuxer (extradata etc.).
libavcodec/wmavoice.c:     * - byte  0-18: WMAPro-in-WMAVoice extradata (see wmaprodec.c),
libavcodec/wmavoice.c:    if (ctx->extradata_size != 46) {
libavcodec/wmavoice.c:               "Invalid extradata size %d (should be 46)\n",
libavcodec/wmavoice.c:               ctx->extradata_size);
libavcodec/wmavoice.c:    flags                = AV_RL32(ctx->extradata + 18);
libavcodec/wmavoice.c:    init_get_bits(&s->gb, ctx->extradata + 22, (ctx->extradata_size - 22) << 3);
libavcodec/wmavoice.c:        av_log(ctx, AV_LOG_ERROR, "Invalid VBM tree; broken extradata?\n");
libavcodec/wmavoice.c:        av_log(ctx, AV_LOG_ERROR, "Invalid pitch range; broken extradata?\n");
libavcodec/wmavoice.c:        av_log(ctx, AV_LOG_ERROR, "Invalid delta pitch hrange; broken extradata?\n");
libavcodec/dvdsubenc.c:static int bprint_to_extradata(AVCodecContext *avctx, struct AVBPrint *buf)
libavcodec/dvdsubenc.c:    avctx->extradata = str;
libavcodec/dvdsubenc.c:    /* Note: the string is NUL terminated (so extradata can be read as a
libavcodec/dvdsubenc.c:     * extradata is copied, it is also padded with AV_INPUT_BUFFER_PADDING_SIZE
libavcodec/dvdsubenc.c:    avctx->extradata_size = buf->len;
libavcodec/dvdsubenc.c:    AVBPrint extradata;
libavcodec/dvdsubenc.c:    av_bprint_init(&extradata, 0, AV_BPRINT_SIZE_AUTOMATIC);
libavcodec/dvdsubenc.c:        av_bprintf(&extradata, "size: %dx%d\n", avctx->width, avctx->height);
libavcodec/dvdsubenc.c:    av_bprintf(&extradata, "palette:");
libavcodec/dvdsubenc.c:        av_bprintf(&extradata, " %06"PRIx32"%c",
libavcodec/dvdsubenc.c:    ret = bprint_to_extradata(avctx, &extradata);
libavcodec/opus.h:static const uint8_t opus_default_extradata[30] = {
libavcodec/opus.h:int ff_opus_parse_extradata(AVCodecContext *avctx, OpusContext *s);
libavcodec/m101.c:    if (avctx->extradata_size < 6*4) {
libavcodec/m101.c:        avpriv_request_sample(avctx, "Missing or too small extradata (size %d)", avctx->extradata_size);
libavcodec/m101.c:    if (avctx->extradata[2*4] == 10)
libavcodec/m101.c:    else if (avctx->extradata[2*4] == 8) {
libavcodec/m101.c:        avpriv_request_sample(avctx, "BPS %d", avctx->extradata[2*4]);
libavcodec/m101.c:    int bits = avctx->extradata[2*4];
libavcodec/m101.c:    stride = AV_RL32(avctx->extradata + 5*4);
libavcodec/m101.c:    frame->interlaced_frame = ((avctx->extradata[3*4] & 3) != 3);
libavcodec/m101.c:        frame->top_field_first = avctx->extradata[3*4] & 1;
libavcodec/asvdec.c:    if (avctx->extradata_size < 1) {
libavcodec/asvdec.c:        av_log(avctx, AV_LOG_WARNING, "No extradata provided\n");
libavcodec/asvdec.c:    if (avctx->extradata_size < 1 || (a->inv_qscale = avctx->extradata[0]) == 0) {
libavcodec/ttmlenc.c:    if (!(avctx->extradata = av_mallocz(TTMLENC_EXTRADATA_SIGNATURE_SIZE +
libavcodec/ttmlenc.c:    avctx->extradata_size = TTMLENC_EXTRADATA_SIGNATURE_SIZE;
libavcodec/ttmlenc.c:    memcpy(avctx->extradata, TTMLENC_EXTRADATA_SIGNATURE,
libavcodec/vorbisdec.c:// Process the extradata using the functions above (identification header, setup header)
libavcodec/vorbisdec.c:    uint8_t *headers   = avctx->extradata;
libavcodec/vorbisdec.c:    int headers_len    = avctx->extradata_size;
libavcodec/amfenc_hevc.c:    // fill extradata
libavcodec/amfenc_hevc.c:    avctx->extradata_size = (int)buffer->pVtbl->GetSize(buffer);
libavcodec/amfenc_hevc.c:    avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/amfenc_hevc.c:    if (!avctx->extradata) {
libavcodec/amfenc_hevc.c:    memcpy(avctx->extradata, buffer->pVtbl->GetNative(buffer), avctx->extradata_size);
libavcodec/libopusenc.c:    uint8_t *p   = avctx->extradata;
libavcodec/libopusenc.c:    avctx->extradata = av_malloc(header_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/libopusenc.c:    if (!avctx->extradata) {
libavcodec/libopusenc.c:        av_log(avctx, AV_LOG_ERROR, "Failed to allocate extradata.\n");
libavcodec/libopusenc.c:    avctx->extradata_size = header_size;
libavcodec/libopusenc.c:    av_freep(&avctx->extradata);
libavcodec/libopusenc.c:    av_freep(&avctx->extradata);
libavcodec/h264_parser.c:        if (avctx->extradata_size) {
libavcodec/h264_parser.c:            ff_h264_decode_extradata(avctx->extradata, avctx->extradata_size,
libavcodec/mediacodecdec.c:static int h264_set_extradata(AVCodecContext *avctx, FFAMediaFormat *format)
libavcodec/mediacodecdec.c:    ret = ff_h264_decode_extradata(avctx->extradata, avctx->extradata_size,
libavcodec/mediacodecdec.c:               "Could not extract PPS/SPS from extradata\n");
libavcodec/mediacodecdec.c:static int hevc_set_extradata(AVCodecContext *avctx, FFAMediaFormat *format)
libavcodec/mediacodecdec.c:    ret = ff_hevc_decode_extradata(avctx->extradata, avctx->extradata_size,
libavcodec/mediacodecdec.c:               "Could not extract VPS/PPS/SPS from extradata\n");
libavcodec/mediacodecdec.c:static int common_set_extradata(AVCodecContext *avctx, FFAMediaFormat *format)
libavcodec/mediacodecdec.c:    if (avctx->extradata) {
libavcodec/mediacodecdec.c:        ff_AMediaFormat_setBuffer(format, "csd-0", avctx->extradata, avctx->extradata_size);
libavcodec/mediacodecdec.c:        ret = h264_set_extradata(avctx, format);
libavcodec/mediacodecdec.c:        ret = hevc_set_extradata(avctx, format);
libavcodec/mediacodecdec.c:        ret = common_set_extradata(avctx, format);
libavcodec/mediacodecdec.c:        ret = common_set_extradata(avctx, format);
libavcodec/mediacodecdec.c:        ret = common_set_extradata(avctx, format);
libavcodec/mediacodecdec.c:        ret = common_set_extradata(avctx, format);
libavcodec/qsvenc_hevc.c:    uint8_t *new_extradata;
libavcodec/qsvenc_hevc.c:    if (!avctx->extradata_size) {
libavcodec/qsvenc_hevc.c:        av_log(avctx, AV_LOG_ERROR, "No extradata returned from libmfx\n");
libavcodec/qsvenc_hevc.c:    av_fast_padded_malloc(&sps_rbsp.rbsp_buffer, &sps_rbsp.rbsp_buffer_alloc_size, avctx->extradata_size);
libavcodec/qsvenc_hevc.c:    ret = ff_h2645_extract_rbsp(avctx->extradata + 4, avctx->extradata_size - 4, &sps_rbsp, &sps_nal, 1);
libavcodec/qsvenc_hevc.c:        av_log(avctx, AV_LOG_ERROR, "Unexpected NAL type in the extradata: %d\n",
libavcodec/qsvenc_hevc.c:    new_extradata = av_mallocz(vps_size + avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/qsvenc_hevc.c:    if (!new_extradata)
libavcodec/qsvenc_hevc.c:    memcpy(new_extradata, vps_buf, vps_size);
libavcodec/qsvenc_hevc.c:    memcpy(new_extradata + vps_size, avctx->extradata, avctx->extradata_size);
libavcodec/qsvenc_hevc.c:    av_freep(&avctx->extradata);
libavcodec/qsvenc_hevc.c:    avctx->extradata       = new_extradata;
libavcodec/qsvenc_hevc.c:    avctx->extradata_size += vps_size;
libavcodec/codec_par.c:    av_freep(&par->extradata);
libavcodec/codec_par.c:    dst->extradata      = NULL;
libavcodec/codec_par.c:    dst->extradata_size = 0;
libavcodec/codec_par.c:    if (src->extradata) {
libavcodec/codec_par.c:        dst->extradata = av_mallocz(src->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/codec_par.c:        if (!dst->extradata)
libavcodec/codec_par.c:        memcpy(dst->extradata, src->extradata, src->extradata_size);
libavcodec/codec_par.c:        dst->extradata_size = src->extradata_size;
libavcodec/codec_par.c:    if (codec->extradata) {
libavcodec/codec_par.c:        par->extradata = av_mallocz(codec->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/codec_par.c:        if (!par->extradata)
libavcodec/codec_par.c:        memcpy(par->extradata, codec->extradata, codec->extradata_size);
libavcodec/codec_par.c:        par->extradata_size = codec->extradata_size;
libavcodec/codec_par.c:    if (par->extradata) {
libavcodec/codec_par.c:        av_freep(&codec->extradata);
libavcodec/codec_par.c:        codec->extradata = av_mallocz(par->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/codec_par.c:        if (!codec->extradata)
libavcodec/codec_par.c:        memcpy(codec->extradata, par->extradata, par->extradata_size);
libavcodec/codec_par.c:        codec->extradata_size = par->extradata_size;
libavcodec/loco.c:    if (avctx->extradata_size < 12) {
libavcodec/loco.c:               avctx->extradata_size);
libavcodec/loco.c:    version = AV_RL32(avctx->extradata);
libavcodec/loco.c:        l->lossy = AV_RL32(avctx->extradata + 8);
libavcodec/loco.c:        l->lossy = AV_RL32(avctx->extradata + 8);
libavcodec/loco.c:    l->mode = AV_RL32(avctx->extradata + 4);
libavcodec/ffwavesynth.c:   Format of the extradata and packets
libavcodec/ffwavesynth.c:   The codec extradata define a set of intervals with uniform content.
libavcodec/ffwavesynth.c:   extradata:
libavcodec/ffwavesynth.c:static int wavesynth_parse_extradata(AVCodecContext *avc)
libavcodec/ffwavesynth.c:    if (avc->extradata_size < 4)
libavcodec/ffwavesynth.c:    edata = avc->extradata;
libavcodec/ffwavesynth.c:    edata_end = edata + avc->extradata_size;
libavcodec/ffwavesynth.c:    r = wavesynth_parse_extradata(avc);
libavcodec/xiph.c:int avpriv_split_xiph_headers(const uint8_t *extradata, int extradata_size,
libavcodec/xiph.c:    if (extradata_size >= 6 && AV_RB16(extradata) == first_header_size) {
libavcodec/xiph.c:            header_len[i] = AV_RB16(extradata);
libavcodec/xiph.c:            extradata += 2;
libavcodec/xiph.c:            header_start[i] = extradata;
libavcodec/xiph.c:            extradata += header_len[i];
libavcodec/xiph.c:            if (overall_len > extradata_size - header_len[i])
libavcodec/xiph.c:    } else if (extradata_size >= 3 && extradata_size < INT_MAX - 0x1ff && extradata[0] == 2) {
libavcodec/xiph.c:        extradata++;
libavcodec/xiph.c:        for (i=0; i<2; i++, extradata++) {
libavcodec/xiph.c:            for (; overall_len < extradata_size && *extradata==0xff; extradata++) {
libavcodec/xiph.c:            header_len[i] += *extradata;
libavcodec/xiph.c:            overall_len   += *extradata;
libavcodec/xiph.c:            if (overall_len > extradata_size)
libavcodec/xiph.c:        header_len[2] = extradata_size - overall_len;
libavcodec/xiph.c:        header_start[0] = extradata;
libavcodec/cbs.h: * Read the extradata bitstream found in codec parameters into a
libavcodec/cbs.h: * codecs with extradata to read parameter sets necessary for further
libavcodec/cbs.h:int ff_cbs_read_extradata(CodedBitstreamContext *ctx,
libavcodec/cbs.h: * Read the extradata bitstream found in a codec context into a
libavcodec/cbs.h: * This acts identical to ff_cbs_read_extradata() for the case where
libavcodec/cbs.h:int ff_cbs_read_extradata_from_codec(CodedBitstreamContext *ctx,
libavcodec/cbs.h: * Write the bitstream of a fragment to the extradata in codec parameters.
libavcodec/cbs.h: * replaces any existing extradata in the structure.
libavcodec/cbs.h:int ff_cbs_write_extradata(CodedBitstreamContext *ctx,
libavcodec/bsf_list.c:    &ff_dump_extradata_bsf,
libavcodec/bsf_list.c:    &ff_extract_extradata_bsf,
libavcodec/bsf_list.c:    &ff_remove_extradata_bsf,
libavcodec/vorbis_parser_internal.h:    int extradata_parsed;       ///< we have attempted to parse extradata
libavcodec/vorbis_parser_internal.h:    int valid_extradata;        ///< extradata is valid, so we can calculate duration
libavcodec/binkaudio.c:    s->version_b = avctx->extradata_size >= 4 && avctx->extradata[3] == 'b';
libavcodec/mpeg4videoenc.c:        s->avctx->extradata = av_malloc(1024);
libavcodec/mpeg4videoenc.c:        if (!s->avctx->extradata)
libavcodec/mpeg4videoenc.c:        init_put_bits(&s->pb, s->avctx->extradata, 1024);
libavcodec/mpeg4videoenc.c:        s->avctx->extradata_size = (put_bits_count(&s->pb) + 7) >> 3;
libavcodec/nuv.c:    if (avctx->extradata_size)
libavcodec/nuv.c:        get_quant(avctx, c, avctx->extradata, avctx->extradata_size);
libavcodec/libx264.c:    av_freep(&avctx->extradata);
libavcodec/libx264.c:        avctx->extradata = p = av_mallocz(s + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/libx264.c:            /* Don't put the SEI in extradata. */
libavcodec/libx264.c:        avctx->extradata_size = p - avctx->extradata;
libavcodec/cbs_bsf.h:    // pkt is NULL, then an extradata header fragment is being updated.
libavcodec/cbs_bsf.h: * the extradata on the input codecpar if any is present.
libavcodec/cbs_bsf.h: * extradata, this should be called after any codec-specific setup is done
libavcodec/cbs_bsf.h: * the same thing to that new extradata to form the output side-data first.
libavcodec/vt_internal.h:CFDataRef ff_videotoolbox_avcc_extradata_create(AVCodecContext *avctx);
libavcodec/vt_internal.h:CFDataRef ff_videotoolbox_hvcc_extradata_create(AVCodecContext *avctx);
libavcodec/iff.c: * Convert CMAP buffer (stored in extradata) to lavc palette format
libavcodec/iff.c:    const uint8_t *const palette = avctx->extradata + AV_RB16(avctx->extradata);
libavcodec/iff.c:    int palette_size = avctx->extradata_size - AV_RB16(avctx->extradata);
libavcodec/iff.c:    // If extradata is smaller than actually needed, fill the remaining with black.
libavcodec/iff.c:    if (avctx->extradata_size < 2) {
libavcodec/iff.c:        av_log(avctx, AV_LOG_ERROR, "not enough extradata\n");
libavcodec/iff.c:    palette_size = avctx->extradata_size - AV_RB16(avctx->extradata);
libavcodec/iff.c:        buf = avctx->extradata;
libavcodec/iff.c:            const uint8_t *const palette = avctx->extradata + AV_RB16(avctx->extradata);
libavcodec/iff.c:        if (avctx->extradata_size >= 2)
libavcodec/iff.c:            palette_size = avctx->extradata_size - AV_RB16(avctx->extradata);
libavcodec/iff.c:                         (avctx->extradata_size >= 2 && palette_size) ? AV_PIX_FMT_PAL8 : AV_PIX_FMT_GRAY8;
libavcodec/libopenh264enc.c:        avctx->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/libopenh264enc.c:        if (!avctx->extradata)
libavcodec/libopenh264enc.c:        avctx->extradata_size = size;
libavcodec/libopenh264enc.c:        memcpy(avctx->extradata, fbi.sLayerInfo[0].pBsBuf, size);
libavcodec/opusenc.c:static void opus_write_extradata(AVCodecContext *avctx)
libavcodec/opusenc.c:    uint8_t *bs = avctx->extradata;
libavcodec/opusenc.c:    av_freep(&avctx->extradata);
libavcodec/opusenc.c:    avctx->extradata_size = 19;
libavcodec/opusenc.c:    avctx->extradata = av_malloc(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/opusenc.c:    if (!avctx->extradata)
libavcodec/opusenc.c:    opus_write_extradata(avctx);
libavcodec/aacdec_template.c:    if (avctx->extradata_size > 0) {
libavcodec/aacdec_template.c:                                                avctx->extradata,
libavcodec/aacdec_template.c:                                                avctx->extradata_size * 8LL,
libavcodec/aacdec_template.c:    buffer_size_t new_extradata_size;
libavcodec/aacdec_template.c:    const uint8_t *new_extradata = av_packet_get_side_data(avpkt,
libavcodec/aacdec_template.c:                                       &new_extradata_size);
libavcodec/aacdec_template.c:    if (new_extradata) {
libavcodec/aacdec_template.c:                                           new_extradata,
libavcodec/aacdec_template.c:                                           new_extradata_size * 8LL, 1);
libavcodec/wmaenc.c:    uint8_t *extradata;
libavcodec/wmaenc.c:        extradata             = av_malloc(4);
libavcodec/wmaenc.c:        if (!extradata)
libavcodec/wmaenc.c:        avctx->extradata_size = 4;
libavcodec/wmaenc.c:        AV_WL16(extradata, flags1);
libavcodec/wmaenc.c:        AV_WL16(extradata + 2, flags2);
libavcodec/wmaenc.c:        extradata             = av_mallocz(10);
libavcodec/wmaenc.c:        if (!extradata)
libavcodec/wmaenc.c:        avctx->extradata_size = 10;
libavcodec/wmaenc.c:        AV_WL32(extradata, flags1);
libavcodec/wmaenc.c:        AV_WL16(extradata + 4, flags2);
libavcodec/wmaenc.c:    avctx->extradata          = extradata;
libavcodec/avcodec.c:    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)
libavcodec/avcodec.c:        av_freep(&avctx->extradata);
libavcodec/avcodec.c:        avctx->extradata_size = 0;
libavcodec/avcodec.c:        av_freep(&avctx->extradata);
libavcodec/mmaldec.c:    int extradata_sent;
libavcodec/mmaldec.c:    ctx->frames_output = ctx->eos_received = ctx->eos_sent = ctx->packets_sent = ctx->extradata_sent = 0;
libavcodec/mmaldec.c:// If is_extradata is set, send it as MMAL_BUFFER_HEADER_FLAG_CONFIG.
libavcodec/mmaldec.c:                             int is_extradata)
libavcodec/mmaldec.c:        if (!is_extradata)
libavcodec/mmaldec.c:        if (is_extradata)
libavcodec/mmaldec.c:    if (avctx->extradata_size && !ctx->extradata_sent) {
libavcodec/mmaldec.c:        pkt.data = avctx->extradata;
libavcodec/mmaldec.c:        pkt.size = avctx->extradata_size;
libavcodec/mmaldec.c:        ctx->extradata_sent = 1;
libavcodec/libcelt_dec.c:    if (c->extradata_size >= 4) {
libavcodec/libcelt_dec.c:        celt->discard = AV_RL32(c->extradata);
libavcodec/libcelt_dec.c:    if (c->extradata_size >= 8) {
libavcodec/libcelt_dec.c:        unsigned version = AV_RL32(c->extradata + 4);
libavcodec/omx.c:                if ((ret = av_reallocp(&avctx->extradata, avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
libavcodec/omx.c:                    avctx->extradata_size = 0;
libavcodec/omx.c:                memcpy(avctx->extradata + avctx->extradata_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
libavcodec/omx.c:                avctx->extradata_size += buffer->nFilledLen;
libavcodec/omx.c:                memset(avctx->extradata + avctx->extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/omx.c:                // For H.264, the extradata can be returned in two separate buffers
libavcodec/omx.c:                for (i = 0; i + 4 < avctx->extradata_size; i++) {
libavcodec/omx.c:                     if (!avctx->extradata[i + 0] &&
libavcodec/omx.c:                         !avctx->extradata[i + 1] &&
libavcodec/omx.c:                         !avctx->extradata[i + 2] &&
libavcodec/omx.c:                         avctx->extradata[i + 3] == 1) {
libavcodec/omx.c:                         nals[avctx->extradata[i + 4] & 0x1f]++;
libavcodec/omx.c:                if (avctx->extradata_size > 0)
libavcodec/omx.c:            if ((ret = av_reallocp(&avctx->extradata, avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
libavcodec/omx.c:                avctx->extradata_size = 0;
libavcodec/omx.c:            memcpy(avctx->extradata + avctx->extradata_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
libavcodec/omx.c:            avctx->extradata_size += buffer->nFilledLen;
libavcodec/omx.c:            memset(avctx->extradata + avctx->extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/bitstream_filters.c:extern const AVBitStreamFilter ff_dump_extradata_bsf;
libavcodec/bitstream_filters.c:extern const AVBitStreamFilter ff_extract_extradata_bsf;
libavcodec/bitstream_filters.c:extern const AVBitStreamFilter ff_remove_extradata_bsf;
libavcodec/libcodec2.c:    if (avctx->extradata_size != CODEC2_EXTRADATA_SIZE) {
libavcodec/libcodec2.c:        av_log(avctx, AV_LOG_ERROR, "must have exactly %i bytes of extradata (got %i)\n",
libavcodec/libcodec2.c:               CODEC2_EXTRADATA_SIZE, avctx->extradata_size);
libavcodec/libcodec2.c:    return libcodec2_init_common(avctx, codec2_mode_from_extradata(avctx->extradata));
libavcodec/libcodec2.c:    avctx->extradata = av_mallocz(CODEC2_EXTRADATA_SIZE + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/libcodec2.c:    if (!avctx->extradata) {
libavcodec/libcodec2.c:    avctx->extradata_size = CODEC2_EXTRADATA_SIZE;
libavcodec/libcodec2.c:    codec2_make_extradata(avctx->extradata, c2->mode);
libavcodec/cuviddec.c:    uint8_t *extradata;
libavcodec/cuviddec.c:    int extradata_size;
libavcodec/cuviddec.c:        extradata = par->extradata;
libavcodec/cuviddec.c:        extradata_size = par->extradata_size;
libavcodec/cuviddec.c:        extradata = avctx->extradata;
libavcodec/cuviddec.c:        extradata_size = avctx->extradata_size;
libavcodec/cuviddec.c:            + FFMAX(extradata_size - (int)sizeof(ctx->cuparse_ext->raw_seqhdr_data), 0));
libavcodec/cuviddec.c:    if (extradata_size > 0)
libavcodec/cuviddec.c:        memcpy(ctx->cuparse_ext->raw_seqhdr_data, extradata, extradata_size);
libavcodec/cuviddec.c:    ctx->cuparse_ext->format.seqhdr_data_length = extradata_size;
libavcodec/qdm2.c: * Init parameters from codec extradata
libavcodec/qdm2.c:    /* extradata parsing
libavcodec/qdm2.c:    if (!avctx->extradata || (avctx->extradata_size < 48)) {
libavcodec/qdm2.c:        av_log(avctx, AV_LOG_ERROR, "extradata missing or truncated\n");
libavcodec/qdm2.c:    bytestream2_init(&gb, avctx->extradata, avctx->extradata_size);
libavcodec/qdm2.c:        av_log(avctx, AV_LOG_ERROR, "not enough extradata (%i)\n",
libavcodec/qdm2.c:        av_log(avctx, AV_LOG_ERROR, "extradata size too small, %i < %i\n",
libavcodec/qdm2.c:        av_log(avctx, AV_LOG_ERROR, "invalid extradata, expecting QDCA\n");
libavcodec/msrle.c:    if (avctx->extradata_size >= 4)
libavcodec/msrle.c:        for (i = 0; i < FFMIN(avctx->extradata_size, AVPALETTE_SIZE)/4; i++)
libavcodec/msrle.c:            s->pal[i] = 0xFFU<<24 | AV_RL32(avctx->extradata+4*i);
libavcodec/rkmppdec.c:    // on first packet, send extradata
libavcodec/rkmppdec.c:        if (avctx->extradata_size) {
libavcodec/rkmppdec.c:            ret = rkmpp_write_data(avctx, avctx->extradata,
libavcodec/rkmppdec.c:                                            avctx->extradata_size,
libavcodec/rkmppdec.c:                av_log(avctx, AV_LOG_ERROR, "Failed to write extradata to decoder (code = %d)\n", ret);
libavcodec/avuienc.c:    if (!(avctx->extradata = av_mallocz(144 + AV_INPUT_BUFFER_PADDING_SIZE)))
libavcodec/avuienc.c:    avctx->extradata_size = 144;
libavcodec/avuienc.c:    memcpy(avctx->extradata, "\0\0\0\x18""APRGAPRG0001", 16);
libavcodec/avuienc.c:        avctx->extradata[19] = 2;
libavcodec/avuienc.c:        avctx->extradata[19] = 1;
libavcodec/avuienc.c:    memcpy(avctx->extradata + 24, "\0\0\0\x78""ARESARES0001""\0\0\0\x98", 20);
libavcodec/avuienc.c:    AV_WB32(avctx->extradata + 44, avctx->width);
libavcodec/avuienc.c:    AV_WB32(avctx->extradata + 48, avctx->height);
libavcodec/avuienc.c:    memcpy(avctx->extradata + 52, "\0\0\0\x1\0\0\0\x20\0\0\0\x2", 12);
libavcodec/microdvddec.c:    if (avctx->extradata) {
libavcodec/microdvddec.c:        microdvd_load_tags(tags, avctx->extradata);
libavcodec/shorten.c:    if (s->avctx->extradata_size > 0)
libavcodec/dvbsubdec.c:    } else if (!avctx->extradata || (avctx->extradata_size < 4) || ((avctx->extradata_size % 5 != 0) && (avctx->extradata_size != 4))) {
libavcodec/dvbsubdec.c:        av_log(avctx, AV_LOG_WARNING, "Invalid DVB subtitles stream extradata!\n");
libavcodec/dvbsubdec.c:        if (avctx->extradata_size > 5*ctx->substream + 2) {
libavcodec/dvbsubdec.c:            ctx->composition_id = AV_RB16(avctx->extradata + 5*ctx->substream);
libavcodec/dvbsubdec.c:            ctx->ancillary_id   = AV_RB16(avctx->extradata + 5*ctx->substream + 2);
libavcodec/dvbsubdec.c:            ctx->composition_id = AV_RB16(avctx->extradata);
libavcodec/dvbsubdec.c:            ctx->ancillary_id   = AV_RB16(avctx->extradata + 2);
libavcodec/flicvideo.c: * the extradata chunk in AVCodecContext. The chunk should be 128 bytes
libavcodec/flicvideo.c:    unsigned char *fli_header = (unsigned char *)avctx->extradata;
libavcodec/flicvideo.c:    if (avctx->extradata_size != 0 &&
libavcodec/flicvideo.c:        avctx->extradata_size != 12 &&
libavcodec/flicvideo.c:        avctx->extradata_size != 128 &&
libavcodec/flicvideo.c:        avctx->extradata_size != 256 &&
libavcodec/flicvideo.c:        avctx->extradata_size != 904 &&
libavcodec/flicvideo.c:        avctx->extradata_size != 1024) {
libavcodec/flicvideo.c:        av_log(avctx, AV_LOG_ERROR, "Unexpected extradata size %d\n", avctx->extradata_size);
libavcodec/flicvideo.c:    if (s->avctx->extradata_size == 12) {
libavcodec/flicvideo.c:    } else if (avctx->extradata_size == 1024) {
libavcodec/flicvideo.c:        uint8_t *ptr = avctx->extradata;
libavcodec/flicvideo.c:    } else if (avctx->extradata_size == 0 ||
libavcodec/flicvideo.c:               avctx->extradata_size == 256 ||
libavcodec/flicvideo.c:               avctx->extradata_size == 904) {
libavcodec/mpeg12dec.c:    int extradata_decoded;
libavcodec/mpeg12dec.c:                if (buf != avctx->extradata)
libavcodec/mpeg12dec.c:    if (avctx->extradata && !s->extradata_decoded) {
libavcodec/mpeg12dec.c:                            avctx->extradata, avctx->extradata_size);
libavcodec/mpeg12dec.c:            av_log(avctx, AV_LOG_ERROR, "picture in extradata\n");
libavcodec/mpeg12dec.c:        s->extradata_decoded = 1;
libavcodec/flac.h: * Validate the FLAC extradata.
libavcodec/flac.h: * @param[in]  avctx codec context containing the extradata.
libavcodec/flac.h: * @param[out] format extradata format.
libavcodec/flac.h:int ff_flac_is_extradata_valid(AVCodecContext *avctx,
libavcodec/vp9dec.h:    AVBufferPool *frame_extradata_pool;
libavcodec/vp9dec.h:    int frame_extradata_pool_size;
libavcodec/h264_mp4toannexb_bsf.c:    int      extradata_parsed;
libavcodec/h264_mp4toannexb_bsf.c:static int h264_extradata_to_annexb(AVBSFContext *ctx, const int padding)
libavcodec/h264_mp4toannexb_bsf.c:    bytestream2_init(gb, ctx->par_in->extradata, ctx->par_in->extradata_size);
libavcodec/h264_mp4toannexb_bsf.c:            av_log(ctx, AV_LOG_ERROR, "Global extradata truncated, "
libavcodec/h264_mp4toannexb_bsf.c:    av_freep(&ctx->par_out->extradata);
libavcodec/h264_mp4toannexb_bsf.c:    ctx->par_out->extradata      = out;
libavcodec/h264_mp4toannexb_bsf.c:    ctx->par_out->extradata_size = total_size;
libavcodec/h264_mp4toannexb_bsf.c:    int extra_size = ctx->par_in->extradata_size;
libavcodec/h264_mp4toannexb_bsf.c:    /* retrieve sps and pps NAL units from extradata */
libavcodec/h264_mp4toannexb_bsf.c:        (extra_size >= 3 && AV_RB24(ctx->par_in->extradata) == 1) ||
libavcodec/h264_mp4toannexb_bsf.c:        (extra_size >= 4 && AV_RB32(ctx->par_in->extradata) == 1)) {
libavcodec/h264_mp4toannexb_bsf.c:        ret = h264_extradata_to_annexb(ctx, AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/h264_mp4toannexb_bsf.c:        s->extradata_parsed = 1;
libavcodec/h264_mp4toannexb_bsf.c:        av_log(ctx, AV_LOG_ERROR, "Invalid extradata size: %d\n", extra_size);
libavcodec/h264_mp4toannexb_bsf.c:    if (!s->extradata_parsed) {
libavcodec/h264_mp4toannexb_bsf.c:                if (ctx->par_out->extradata)
libavcodec/h264_mp4toannexb_bsf.c:                    count_or_copy(&out, &out_size, ctx->par_out->extradata,
libavcodec/h264_mp4toannexb_bsf.c:                                  ctx->par_out->extradata_size, -1, j);
libavcodec/h264_mp4toannexb_bsf.c:    s->new_idr      = s->extradata_parsed;
libavcodec/sonic.c:    avctx->extradata = av_mallocz(16);
libavcodec/sonic.c:    if (!avctx->extradata)
libavcodec/sonic.c:    init_put_bits(&pb, avctx->extradata, 16*8);
libavcodec/sonic.c:    avctx->extradata_size = put_bits_count(&pb)/8;
libavcodec/sonic.c:    if (!avctx->extradata)
libavcodec/sonic.c:    ret = init_get_bits8(&gb, avctx->extradata, avctx->extradata_size);
libavcodec/wmv2enc.c:    init_put_bits(&pb, s->avctx->extradata, s->avctx->extradata_size);
libavcodec/wmv2enc.c:    avctx->extradata_size = 4;
libavcodec/wmv2enc.c:    avctx->extradata      = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/wmv2enc.c:    if (!avctx->extradata)
libavcodec/av1dec.c:    if (avctx->extradata && avctx->extradata_size) {
libavcodec/av1dec.c:        ret = ff_cbs_read_extradata_from_codec(s->cbc,
libavcodec/av1dec.c:            av_log(avctx, AV_LOG_WARNING, "Failed to read extradata.\n");
libavcodec/av1_frame_split_bsf.c:    if (!ctx->par_in->extradata_size)
libavcodec/av1_frame_split_bsf.c:    ret = ff_cbs_read_extradata(s->cbc, td, ctx->par_in);
libavcodec/av1_frame_split_bsf.c:        av_log(ctx, AV_LOG_WARNING, "Failed to parse extradata.\n");
libavcodec/wmv2dec.c:    if (s->avctx->extradata_size < 4)
libavcodec/wmv2dec.c:    init_get_bits(&gb, s->avctx->extradata, 32);
libavcodec/vmdvideo.c: * a 0x330-byte VMD file header to be transmitted via extradata during
libavcodec/vmdvideo.c:    if (s->avctx->extradata_size != VMD_HEADER_SIZE) {
libavcodec/vmdvideo.c:        av_log(s->avctx, AV_LOG_ERROR, "expected extradata size of %d\n",
libavcodec/vmdvideo.c:    vmd_header = (unsigned char *)avctx->extradata;
libavcodec/opus.c:av_cold int ff_opus_parse_extradata(AVCodecContext *avctx,
libavcodec/opus.c:    const uint8_t *extradata, *channel_map;
libavcodec/opus.c:    int extradata_size;
libavcodec/opus.c:    if (!avctx->extradata) {
libavcodec/opus.c:                   "Multichannel configuration without extradata.\n");
libavcodec/opus.c:        extradata      = opus_default_extradata;
libavcodec/opus.c:        extradata_size = sizeof(opus_default_extradata);
libavcodec/opus.c:        extradata = avctx->extradata;
libavcodec/opus.c:        extradata_size = avctx->extradata_size;
libavcodec/opus.c:    if (extradata_size < 19) {
libavcodec/opus.c:        av_log(avctx, AV_LOG_ERROR, "Invalid extradata size: %d\n",
libavcodec/opus.c:               extradata_size);
libavcodec/opus.c:    version = extradata[8];
libavcodec/opus.c:    avctx->delay = AV_RL16(extradata + 10);
libavcodec/opus.c:    channels = avctx->extradata ? extradata[9] : (avctx->channels == 1) ? 1 : 2;
libavcodec/opus.c:        av_log(avctx, AV_LOG_ERROR, "Zero channel count specified in the extradata\n");
libavcodec/opus.c:    s->gain_i = AV_RL16(extradata + 16);
libavcodec/opus.c:    map_type = extradata[18];
libavcodec/opus.c:        if (extradata_size < 21 + channels) {
libavcodec/opus.c:            av_log(avctx, AV_LOG_ERROR, "Invalid extradata size: %d\n",
libavcodec/opus.c:                   extradata_size);
libavcodec/opus.c:        streams        = extradata[19];
libavcodec/opus.c:        stereo_streams = extradata[20];
libavcodec/opus.c:        channel_map = extradata + 21;
libavcodec/vp9shared.h:    AVBufferRef *extradata;
libavcodec/avuidec.c:    const uint8_t *src = avpkt->data, *extradata = avctx->extradata;
libavcodec/avuidec.c:    uint32_t extradata_size = avctx->extradata_size;
libavcodec/avuidec.c:    while (extradata_size >= 24) {
libavcodec/avuidec.c:        uint32_t atom_size = AV_RB32(extradata);
libavcodec/avuidec.c:        if (!memcmp(&extradata[4], "APRGAPRG0001", 12)) {
libavcodec/avuidec.c:            interlaced = extradata[19] != 1;
libavcodec/avuidec.c:        if (atom_size && atom_size <= extradata_size) {
libavcodec/avuidec.c:            extradata      += atom_size;
libavcodec/avuidec.c:            extradata_size -= atom_size;
libavcodec/videotoolbox.c:CFDataRef ff_videotoolbox_avcc_extradata_create(AVCodecContext *avctx)
libavcodec/videotoolbox.c:    int vt_extradata_size = 6 + 2 + h->ps.sps->data_size + 3 + h->ps.pps->data_size;
libavcodec/videotoolbox.c:    uint8_t *vt_extradata = av_malloc(vt_extradata_size);
libavcodec/videotoolbox.c:    if (!vt_extradata)
libavcodec/videotoolbox.c:    p = vt_extradata;
libavcodec/videotoolbox.c:    av_assert0(p - vt_extradata == vt_extradata_size);
libavcodec/videotoolbox.c:    data = CFDataCreate(kCFAllocatorDefault, vt_extradata, vt_extradata_size);
libavcodec/videotoolbox.c:    av_free(vt_extradata);
libavcodec/videotoolbox.c:CFDataRef ff_videotoolbox_hvcc_extradata_create(AVCodecContext *avctx)
libavcodec/videotoolbox.c:    int vt_extradata_size = 23 + 3 + 3 + 3;
libavcodec/videotoolbox.c:    uint8_t *vt_extradata;
libavcodec/videotoolbox.c:            vt_extradata_size += 2 + lps->data_size; \
libavcodec/videotoolbox.c:    vt_extradata = av_malloc(vt_extradata_size);
libavcodec/videotoolbox.c:    if (!vt_extradata)
libavcodec/videotoolbox.c:    p = vt_extradata;
libavcodec/videotoolbox.c:    av_assert0(p - vt_extradata == vt_extradata_size);
libavcodec/videotoolbox.c:    data = CFDataCreate(kCFAllocatorDefault, vt_extradata, vt_extradata_size);
libavcodec/videotoolbox.c:    av_free(vt_extradata);
libavcodec/videotoolbox.c:static CFDataRef videotoolbox_esds_extradata_create(AVCodecContext *avctx)
libavcodec/videotoolbox.c:    uint8_t *rw_extradata;
libavcodec/videotoolbox.c:    int full_size = 3 + 5 + 13 + 5 + avctx->extradata_size + 3;
libavcodec/videotoolbox.c:    int config_size = 13 + 5 + avctx->extradata_size;
libavcodec/videotoolbox.c:    if (!(rw_extradata = av_mallocz(full_size + VIDEOTOOLBOX_ESDS_EXTRADATA_PADDING)))
libavcodec/videotoolbox.c:    bytestream2_init_writer(&pb, rw_extradata, full_size + VIDEOTOOLBOX_ESDS_EXTRADATA_PADDING);
libavcodec/videotoolbox.c:    videotoolbox_write_mp4_descr_length(&pb, avctx->extradata_size);
libavcodec/videotoolbox.c:    bytestream2_put_buffer(&pb, avctx->extradata, avctx->extradata_size);
libavcodec/videotoolbox.c:    data = CFDataCreate(kCFAllocatorDefault, rw_extradata, s);
libavcodec/videotoolbox.c:    av_freep(&rw_extradata);
libavcodec/videotoolbox.c:        if (avctx->extradata_size)
libavcodec/videotoolbox.c:            data = videotoolbox_esds_extradata_create(avctx);
libavcodec/videotoolbox.c:        data = ff_videotoolbox_avcc_extradata_create(avctx);
libavcodec/videotoolbox.c:        data = ff_videotoolbox_hvcc_extradata_create(avctx);
libavcodec/nvenc.c:static av_cold int nvenc_setup_extradata(AVCodecContext *avctx)
libavcodec/nvenc.c:    avctx->extradata_size = outSize;
libavcodec/nvenc.c:    avctx->extradata = av_mallocz(outSize + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/nvenc.c:    if (!avctx->extradata) {
libavcodec/nvenc.c:    memcpy(avctx->extradata, tmpHeader, outSize);
libavcodec/nvenc.c:        if ((ret = nvenc_setup_extradata(avctx)) < 0)
libavcodec/sanm.c:    ctx->version = !avctx->extradata_size;
libavcodec/sanm.c:    if (!ctx->version && avctx->extradata_size < 1026) {
libavcodec/sanm.c:        av_log(avctx, AV_LOG_ERROR, "Not enough extradata.\n");
libavcodec/sanm.c:        ctx->subversion = AV_RL16(avctx->extradata);
libavcodec/sanm.c:            ctx->pal[i] = 0xFFU << 24 | AV_RL32(avctx->extradata + 2 + i * 4);
libavcodec/asvenc.c:    avctx->extradata                   = av_mallocz(8);
libavcodec/asvenc.c:    if (!avctx->extradata)
libavcodec/asvenc.c:    avctx->extradata_size              = 8;
libavcodec/asvenc.c:    ((uint32_t *) avctx->extradata)[0] = av_le2ne32(a->inv_qscale);
libavcodec/asvenc.c:    ((uint32_t *) avctx->extradata)[1] = av_le2ne32(AV_RL32("ASUS"));
libavcodec/hevc_mp4toannexb_bsf.c:    int      extradata_parsed;
libavcodec/hevc_mp4toannexb_bsf.c:static int hevc_extradata_to_annexb(AVBSFContext *ctx)
libavcodec/hevc_mp4toannexb_bsf.c:    uint8_t *new_extradata = NULL;
libavcodec/hevc_mp4toannexb_bsf.c:    size_t   new_extradata_size = 0;
libavcodec/hevc_mp4toannexb_bsf.c:    bytestream2_init(&gb, ctx->par_in->extradata, ctx->par_in->extradata_size);
libavcodec/hevc_mp4toannexb_bsf.c:            av_log(ctx, AV_LOG_ERROR, "Invalid NAL unit type in extradata: %d\n",
libavcodec/hevc_mp4toannexb_bsf.c:            if (4 + AV_INPUT_BUFFER_PADDING_SIZE + nalu_len > SIZE_MAX - new_extradata_size) {
libavcodec/hevc_mp4toannexb_bsf.c:            ret = av_reallocp(&new_extradata, new_extradata_size + nalu_len + 4 + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/hevc_mp4toannexb_bsf.c:            AV_WB32(new_extradata + new_extradata_size, 1); // add the startcode
libavcodec/hevc_mp4toannexb_bsf.c:            bytestream2_get_buffer(&gb, new_extradata + new_extradata_size + 4, nalu_len);
libavcodec/hevc_mp4toannexb_bsf.c:            new_extradata_size += 4 + nalu_len;
libavcodec/hevc_mp4toannexb_bsf.c:            memset(new_extradata + new_extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/hevc_mp4toannexb_bsf.c:    av_freep(&ctx->par_out->extradata);
libavcodec/hevc_mp4toannexb_bsf.c:    ctx->par_out->extradata      = new_extradata;
libavcodec/hevc_mp4toannexb_bsf.c:    ctx->par_out->extradata_size = new_extradata_size;
libavcodec/hevc_mp4toannexb_bsf.c:    if (!new_extradata_size)
libavcodec/hevc_mp4toannexb_bsf.c:        av_log(ctx, AV_LOG_WARNING, "No parameter sets in the extradata\n");
libavcodec/hevc_mp4toannexb_bsf.c:    av_freep(&new_extradata);
libavcodec/hevc_mp4toannexb_bsf.c:    if (ctx->par_in->extradata_size < MIN_HEVCC_LENGTH ||
libavcodec/hevc_mp4toannexb_bsf.c:        AV_RB24(ctx->par_in->extradata) == 1           ||
libavcodec/hevc_mp4toannexb_bsf.c:        AV_RB32(ctx->par_in->extradata) == 1) {
libavcodec/hevc_mp4toannexb_bsf.c:        ret = hevc_extradata_to_annexb(ctx);
libavcodec/hevc_mp4toannexb_bsf.c:        s->extradata_parsed = 1;
libavcodec/hevc_mp4toannexb_bsf.c:    if (!s->extradata_parsed) {
libavcodec/hevc_mp4toannexb_bsf.c:        int is_irap, add_extradata, extra_size, prev_size;
libavcodec/hevc_mp4toannexb_bsf.c:        /* prepend extradata to IRAP frames */
libavcodec/hevc_mp4toannexb_bsf.c:        add_extradata = is_irap && !got_irap;
libavcodec/hevc_mp4toannexb_bsf.c:        extra_size    = add_extradata * ctx->par_out->extradata_size;
libavcodec/hevc_mp4toannexb_bsf.c:            memcpy(out->data + prev_size, ctx->par_out->extradata, extra_size);
libavcodec/utils.c:                                    uint8_t * extradata, int frame_size, int frame_bytes)
libavcodec/utils.c:                if (extradata)
libavcodec/utils.c:                                    avctx->bit_rate, avctx->extradata, avctx->frame_size,
libavcodec/utils.c:                                    par->bit_rate, par->extradata, par->frame_size,
libavcodec/audiotoolboxdec.c:    uint8_t *extradata;
libavcodec/audiotoolboxdec.c:    int extradata_size;
libavcodec/audiotoolboxdec.c:        char *extradata;
libavcodec/audiotoolboxdec.c:        *cookie_size = 5 + 3 + 5+13 + 5+at->extradata_size;
libavcodec/audiotoolboxdec.c:        if (!(extradata = av_malloc(*cookie_size)))
libavcodec/audiotoolboxdec.c:        bytestream2_init_writer(&pb, extradata, *cookie_size);
libavcodec/audiotoolboxdec.c:        put_descr(&pb, 0x03, 3 + 5+13 + 5+at->extradata_size);
libavcodec/audiotoolboxdec.c:        put_descr(&pb, 0x04, 13 + 5+at->extradata_size);
libavcodec/audiotoolboxdec.c:        put_descr(&pb, 0x05, at->extradata_size);
libavcodec/audiotoolboxdec.c:        bytestream2_put_buffer(&pb, at->extradata, at->extradata_size);
libavcodec/audiotoolboxdec.c:        return extradata;
libavcodec/audiotoolboxdec.c:        *cookie_size = at->extradata_size;
libavcodec/audiotoolboxdec.c:        return at->extradata;
libavcodec/audiotoolboxdec.c:static av_cold int ffat_usable_extradata(AVCodecContext *avctx)
libavcodec/audiotoolboxdec.c:    return at->extradata_size &&
libavcodec/audiotoolboxdec.c:static int ffat_set_extradata(AVCodecContext *avctx)
libavcodec/audiotoolboxdec.c:    if (ffat_usable_extradata(avctx)) {
libavcodec/audiotoolboxdec.c:        if (cookie != at->extradata)
libavcodec/audiotoolboxdec.c:    if (ffat_usable_extradata(avctx)) {
libavcodec/audiotoolboxdec.c:        if (cookie != at->extradata)
libavcodec/audiotoolboxdec.c:    if ((status = ffat_set_extradata(avctx)) < 0)
libavcodec/audiotoolboxdec.c:    if (avctx->extradata_size) {
libavcodec/audiotoolboxdec.c:        at->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/audiotoolboxdec.c:        if (!at->extradata)
libavcodec/audiotoolboxdec.c:        at->extradata_size = avctx->extradata_size;
libavcodec/audiotoolboxdec.c:        memcpy(at->extradata, avctx->extradata, avctx->extradata_size);
libavcodec/audiotoolboxdec.c:    if ((avctx->channels && avctx->sample_rate) || ffat_usable_extradata(avctx))
libavcodec/audiotoolboxdec.c:        if (!at->extradata_size) {
libavcodec/audiotoolboxdec.c:                at->extradata = av_mallocz(side_data_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/audiotoolboxdec.c:                if (!at->extradata)
libavcodec/audiotoolboxdec.c:                at->extradata_size = side_data_size;
libavcodec/audiotoolboxdec.c:                memcpy(at->extradata, side_data, side_data_size);
libavcodec/audiotoolboxdec.c:    av_freep(&at->extradata);
libavcodec/twinvqdec.c:    if (!avctx->extradata || avctx->extradata_size < 12) {
libavcodec/twinvqdec.c:        av_log(avctx, AV_LOG_ERROR, "Missing or incomplete extradata\n");
libavcodec/twinvqdec.c:    avctx->channels = AV_RB32(avctx->extradata)     + 1;
libavcodec/twinvqdec.c:    avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;
libavcodec/twinvqdec.c:    isampf          = AV_RB32(avctx->extradata + 8);
libavcodec/hcadec.c:    ret = init_get_bits8(gb, avctx->extradata, avctx->extradata_size);
libavcodec/hcom.c:    if (avctx->extradata_size <= 7)
libavcodec/hcom.c:    s->dict_entries = AV_RB16(avctx->extradata);
libavcodec/hcom.c:    if (avctx->extradata_size < s->dict_entries * 4 + 7 ||
libavcodec/hcom.c:    s->delta_compression = AV_RB32(avctx->extradata + 2);
libavcodec/hcom.c:    s->sample = s->first_sample = avctx->extradata[avctx->extradata_size - 1];
libavcodec/hcom.c:        s->dict[i].l = AV_RB16(avctx->extradata + 6 + 4 * i);
libavcodec/hcom.c:        s->dict[i].r = AV_RB16(avctx->extradata + 6 + 4 * i + 2);
libavcodec/rv30.c:        if (avctx->extradata_size < rpr * 2 + 8) {
libavcodec/rv30.c:                   "Insufficient extradata - need at least %d bytes, got %d\n",
libavcodec/rv30.c:                   8 + rpr * 2, avctx->extradata_size);
libavcodec/rv30.c:        w = r->s.avctx->extradata[6 + rpr*2] << 2;
libavcodec/rv30.c:        h = r->s.avctx->extradata[7 + rpr*2] << 2;
libavcodec/rv30.c:    if (avctx->extradata_size < 2) {
libavcodec/rv30.c:    r->max_rpr = avctx->extradata[1] & 7;
libavcodec/rv30.c:    if(avctx->extradata_size < 2*r->max_rpr + 8){
libavcodec/rv30.c:        av_log(avctx, AV_LOG_WARNING, "Insufficient extradata - need at least %d bytes, got %d\n",
libavcodec/rv30.c:               2*r->max_rpr + 8, avctx->extradata_size);
libavcodec/hevc_parse.h:int ff_hevc_decode_extradata(const uint8_t *data, int size, HEVCParamSets *ps,
libavcodec/vaapi_encode.h:    // The sequence header is also used to fill the codec extradata
libavcodec/internal.h: * Maximum size in bytes of extradata.
libavcodec/msvideo1.c:        if (avctx->extradata_size >= AVPALETTE_SIZE)
libavcodec/msvideo1.c:            memcpy(s->pal, avctx->extradata, AVPALETTE_SIZE);
libavcodec/crystalhd.c:        format.pMetaData  = avctx->extradata;
libavcodec/crystalhd.c:        format.metaDataSz = avctx->extradata_size;
libavcodec/flacenc.c:    avctx->extradata = streaminfo;
libavcodec/flacenc.c:    avctx->extradata_size = FLAC_STREAMINFO_SIZE;
libavcodec/flacenc.c:    /* when the last block is reached, update the header in extradata */
libavcodec/flacenc.c:        write_streaminfo(s, avctx->extradata);
libavcodec/flacenc.c:                                                         avctx->extradata_size);
libavcodec/flacenc.c:            memcpy(side_data, avctx->extradata, avctx->extradata_size);
libavcodec/flacenc.c:    av_freep(&avctx->extradata);
libavcodec/flacenc.c:    avctx->extradata_size = 0;
libavcodec/dump_extradata_bsf.c:static int dump_extradata(AVBSFContext *ctx, AVPacket *out)
libavcodec/dump_extradata_bsf.c:    if (ctx->par_in->extradata &&
libavcodec/dump_extradata_bsf.c:         (in->size < ctx->par_in->extradata_size ||
libavcodec/dump_extradata_bsf.c:          memcmp(in->data, ctx->par_in->extradata, ctx->par_in->extradata_size))) {
libavcodec/dump_extradata_bsf.c:        if (in->size >= INT_MAX - ctx->par_in->extradata_size) {
libavcodec/dump_extradata_bsf.c:        ret = av_new_packet(out, in->size + ctx->par_in->extradata_size);
libavcodec/dump_extradata_bsf.c:        memcpy(out->data, ctx->par_in->extradata, ctx->par_in->extradata_size);
libavcodec/dump_extradata_bsf.c:        memcpy(out->data + ctx->par_in->extradata_size, in->data, in->size);
libavcodec/dump_extradata_bsf.c:    { "freq", "When to dump extradata", OFFSET(freq), AV_OPT_TYPE_INT,
libavcodec/dump_extradata_bsf.c:static const AVClass dump_extradata_class = {
libavcodec/dump_extradata_bsf.c:    .class_name = "dump_extradata bsf",
libavcodec/dump_extradata_bsf.c:const AVBitStreamFilter ff_dump_extradata_bsf = {
libavcodec/dump_extradata_bsf.c:    .priv_class     = &dump_extradata_class,
libavcodec/dump_extradata_bsf.c:    .filter         = dump_extradata,
libavcodec/libx265.c:        avctx->extradata_size = ctx->api->encoder_headers(ctx->encoder, &nal, &nnal);
libavcodec/libx265.c:        if (avctx->extradata_size <= 0) {
libavcodec/libx265.c:        avctx->extradata = av_malloc(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/libx265.c:        if (!avctx->extradata) {
libavcodec/libx265.c:                   "Cannot allocate HEVC header of size %d.\n", avctx->extradata_size);
libavcodec/libx265.c:        memcpy(avctx->extradata, nal[0].payload, avctx->extradata_size);
libavcodec/libx265.c:        memset(avctx->extradata + avctx->extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/avrndec.c:    if(avctx->extradata_size >= 9 && avctx->extradata[4]+28 < avctx->extradata_size) {
libavcodec/avrndec.c:        int ndx = avctx->extradata[4] + 4;
libavcodec/avrndec.c:        a->interlace = !memcmp(avctx->extradata + ndx, "1:1(", 4);
libavcodec/avrndec.c:            a->tff = avctx->extradata[ndx + 24] == 1;
libavcodec/opus_parser.c:    int extradata_parsed;
libavcodec/opus_parser.c:    if (avctx->extradata && !s->extradata_parsed) {
libavcodec/opus_parser.c:        ret = ff_opus_parse_extradata(avctx, &s->ctx);
libavcodec/opus_parser.c:            av_log(avctx, AV_LOG_ERROR, "Error parsing Ogg extradata.\n");
libavcodec/opus_parser.c:        s->extradata_parsed = 1;
libavcodec/assdec.c:    avctx->subtitle_header = av_malloc(avctx->extradata_size + 1);
libavcodec/assdec.c:    if (avctx->extradata_size)
libavcodec/assdec.c:        memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);
libavcodec/assdec.c:    avctx->subtitle_header[avctx->extradata_size] = 0;
libavcodec/assdec.c:    avctx->subtitle_header_size = avctx->extradata_size;
libavcodec/libsvtav1.c:        avctx->extradata_size = headerPtr->n_filled_len;
libavcodec/libsvtav1.c:        avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/libsvtav1.c:        if (!avctx->extradata) {
libavcodec/libsvtav1.c:                   "Cannot allocate AV1 header of size %d.\n", avctx->extradata_size);
libavcodec/libsvtav1.c:        memcpy(avctx->extradata, headerPtr->p_buffer, avctx->extradata_size);
libavcodec/videotoolboxenc.c:static int vtenc_populate_extradata(AVCodecContext   *avctx,
libavcodec/videotoolboxenc.c:static int set_extradata(AVCodecContext *avctx, CMSampleBufferRef sample_buffer)
libavcodec/videotoolboxenc.c:    avctx->extradata = av_mallocz(total_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/videotoolboxenc.c:    if (!avctx->extradata) {
libavcodec/videotoolboxenc.c:    avctx->extradata_size = total_size;
libavcodec/videotoolboxenc.c:    status = copy_param_sets(avctx, vid_fmt, avctx->extradata, total_size);
libavcodec/videotoolboxenc.c:    if (!avctx->extradata && (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER)) {
libavcodec/videotoolboxenc.c:        int set_status = set_extradata(avctx, sample_buffer);
libavcodec/videotoolboxenc.c:        status = vtenc_populate_extradata(avctx,
libavcodec/videotoolboxenc.c:static int vtenc_populate_extradata(AVCodecContext   *avctx,
libavcodec/videotoolboxenc.c:               "Error sending frame for extradata: %d\n",
libavcodec/videotoolboxenc.c:    //Populates extradata - output frames are flushed and param sets are available.
libavcodec/videotoolboxenc.c:    av_assert0(status != 0 || (avctx->extradata && avctx->extradata_size > 0));
libavcodec/hevc_parse.c:            av_log(logctx, AV_LOG_VERBOSE, "Ignoring NAL type %d in extradata\n", nal->type);
libavcodec/hevc_parse.c:int ff_hevc_decode_extradata(const uint8_t *data, int size, HEVCParamSets *ps,
libavcodec/hevc_parse.c:        /* It seems the extradata is encoded as hvcC format.
libavcodec/hevc_parse.c:         * can recognize hvcC by checking if avctx->extradata[0]==1 or not. */
libavcodec/hevc_parse.c:                           "Invalid NAL unit size in extradata.\n");
libavcodec/flacdec.c: * 34-byte streaminfo structure through avctx->extradata[_size] followed
libavcodec/flacdec.c:       frame data instead of extradata. */
libavcodec/flacdec.c:    if (!avctx->extradata)
libavcodec/flacdec.c:    if (!ff_flac_is_extradata_valid(avctx, &format, &streaminfo))
libavcodec/extract_extradata_bsf.d:libavcodec/extract_extradata_bsf.o: libavcodec/extract_extradata_bsf.c \
libavcodec/qpeg.c:    pal_size = FFMIN(1024U, avctx->extradata_size);
libavcodec/qpeg.c:    pal_src = avctx->extradata + avctx->extradata_size - pal_size;
libavcodec/movtextenc.c:    avctx->extradata_size = s->buffer.len;
libavcodec/movtextenc.c:    avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/movtextenc.c:    if (!avctx->extradata) {
libavcodec/movtextenc.c:    memcpy(avctx->extradata, s->buffer.str, avctx->extradata_size);
libavcodec/smacker.c:    mmap_size = AV_RL32(smk->avctx->extradata);
libavcodec/smacker.c:    mclr_size = AV_RL32(smk->avctx->extradata + 4);
libavcodec/smacker.c:    full_size = AV_RL32(smk->avctx->extradata + 8);
libavcodec/smacker.c:    type_size = AV_RL32(smk->avctx->extradata + 12);
libavcodec/smacker.c:    ret = init_get_bits8(&gb, smk->avctx->extradata + 16, smk->avctx->extradata_size - 16);
libavcodec/smacker.c:    /* decode huffman trees from extradata */
libavcodec/smacker.c:    if (avctx->extradata_size <= 16){
libavcodec/rl2.c:    if (!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE) {
libavcodec/rl2.c:        av_log(avctx, AV_LOG_ERROR, "invalid extradata size\n");
libavcodec/rl2.c:    s->video_base = AV_RL16(&avctx->extradata[0]);
libavcodec/rl2.c:    s->clr_count  = AV_RL32(&avctx->extradata[2]);
libavcodec/rl2.c:        s->palette[i] = 0xFFU << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);
libavcodec/rl2.c:    back_size = avctx->extradata_size - EXTRADATA1_SIZE;
libavcodec/rl2.c:        rl2_rle_decode(s, avctx->extradata + EXTRADATA1_SIZE, back_size,
libavcodec/vorbis_parser.c:                             const uint8_t *extradata, int extradata_size)
libavcodec/vorbis_parser.c:    s->extradata_parsed = 1;
libavcodec/vorbis_parser.c:    if ((ret = avpriv_split_xiph_headers(extradata,
libavcodec/vorbis_parser.c:                                         extradata_size, 30,
libavcodec/vorbis_parser.c:    s->valid_extradata = 1;
libavcodec/vorbis_parser.c:    if (s->valid_extradata && buf_size > 0) {
libavcodec/vorbis_parser.c:    if (s->valid_extradata)
libavcodec/vorbis_parser.c:AVVorbisParseContext *av_vorbis_parse_init(const uint8_t *extradata,
libavcodec/vorbis_parser.c:                                           int extradata_size)
libavcodec/vorbis_parser.c:    ret = vorbis_parse_init(s, extradata, extradata_size);
libavcodec/vorbis_parser.c:    if (!s->vp && avctx->extradata && avctx->extradata_size) {
libavcodec/vorbis_parser.c:        s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);
libavcodec/vp9.c:    av_buffer_unref(&f->extradata);
libavcodec/vp9.c:    if (sz != s->frame_extradata_pool_size) {
libavcodec/vp9.c:        av_buffer_pool_uninit(&s->frame_extradata_pool);
libavcodec/vp9.c:        s->frame_extradata_pool = av_buffer_pool_init(sz * (1 + sizeof(VP9mvrefPair)), NULL);
libavcodec/vp9.c:        if (!s->frame_extradata_pool) {
libavcodec/vp9.c:            s->frame_extradata_pool_size = 0;
libavcodec/vp9.c:        s->frame_extradata_pool_size = sz;
libavcodec/vp9.c:    f->extradata = av_buffer_pool_get(s->frame_extradata_pool);
libavcodec/vp9.c:    if (!f->extradata) {
libavcodec/vp9.c:    memset(f->extradata->data, 0, f->extradata->size);
libavcodec/vp9.c:    f->segmentation_map = f->extradata->data;
libavcodec/vp9.c:    f->mv = (VP9mvrefPair *) (f->extradata->data + sz);
libavcodec/vp9.c:    dst->extradata = av_buffer_ref(src->extradata);
libavcodec/vp9.c:    if (!dst->extradata)
libavcodec/vp9.c:    av_buffer_pool_uninit(&s->frame_extradata_pool);
libavcodec/magicyuvenc.c:    avctx->extradata_size = 32;
libavcodec/magicyuvenc.c:    avctx->extradata = av_mallocz(avctx->extradata_size +
libavcodec/magicyuvenc.c:    if (!avctx->extradata) {
libavcodec/magicyuvenc.c:        av_log(avctx, AV_LOG_ERROR, "Could not allocate extradata.\n");
libavcodec/magicyuvenc.c:    bytestream2_init_writer(&pb, avctx->extradata, avctx->extradata_size);
libavcodec/dump_extradata_bsf.d:libavcodec/dump_extradata_bsf.o: libavcodec/dump_extradata_bsf.c \
libavcodec/cbs.c:int ff_cbs_read_extradata(CodedBitstreamContext *ctx,
libavcodec/cbs.c:                         par->extradata,
libavcodec/cbs.c:                         par->extradata_size, 1);
libavcodec/cbs.c:int ff_cbs_read_extradata_from_codec(CodedBitstreamContext *ctx,
libavcodec/cbs.c:                         avctx->extradata,
libavcodec/cbs.c:                         avctx->extradata_size, 1);
libavcodec/cbs.c:int ff_cbs_write_extradata(CodedBitstreamContext *ctx,
libavcodec/cbs.c:    av_freep(&par->extradata);
libavcodec/cbs.c:    par->extradata = av_malloc(frag->data_size +
libavcodec/cbs.c:    if (!par->extradata)
libavcodec/cbs.c:    memcpy(par->extradata, frag->data, frag->data_size);
libavcodec/cbs.c:    memset(par->extradata + frag->data_size, 0,
libavcodec/cbs.c:    par->extradata_size = frag->data_size;
libavcodec/amfenc_h264.c:    // fill extradata
libavcodec/amfenc_h264.c:    avctx->extradata_size = (int)buffer->pVtbl->GetSize(buffer);
libavcodec/amfenc_h264.c:    avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/amfenc_h264.c:    if (!avctx->extradata) {
libavcodec/amfenc_h264.c:    memcpy(avctx->extradata, buffer->pVtbl->GetNative(buffer), avctx->extradata_size);
libavcodec/mss12.c:    if (avctx->extradata_size < 52 + 256 * 3) {
libavcodec/mss12.c:        av_log(avctx, AV_LOG_ERROR, "Insufficient extradata size %d\n",
libavcodec/mss12.c:               avctx->extradata_size);
libavcodec/mss12.c:    if (AV_RB32(avctx->extradata) < avctx->extradata_size) {
libavcodec/mss12.c:               "Insufficient extradata size: expected %"PRIu32" got %d\n",
libavcodec/mss12.c:               AV_RB32(avctx->extradata),
libavcodec/mss12.c:               avctx->extradata_size);
libavcodec/mss12.c:    avctx->coded_width  = FFMAX(AV_RB32(avctx->extradata + 20), avctx->width);
libavcodec/mss12.c:    avctx->coded_height = FFMAX(AV_RB32(avctx->extradata + 24), avctx->height);
libavcodec/mss12.c:           AV_RB32(avctx->extradata + 4), AV_RB32(avctx->extradata + 8));
libavcodec/mss12.c:    if (version != AV_RB32(avctx->extradata + 4) > 1) {
libavcodec/mss12.c:    c->free_colours = AV_RB32(avctx->extradata + 48);
libavcodec/mss12.c:           AV_RB32(avctx->extradata + 12), AV_RB32(avctx->extradata + 16));
libavcodec/mss12.c:           av_int2float(AV_RB32(avctx->extradata + 28)));
libavcodec/mss12.c:           AV_RB32(avctx->extradata + 32));
libavcodec/mss12.c:           av_int2float(AV_RB32(avctx->extradata + 36)));
libavcodec/mss12.c:           av_int2float(AV_RB32(avctx->extradata + 40)));
libavcodec/mss12.c:           av_int2float(AV_RB32(avctx->extradata + 44)));
libavcodec/mss12.c:        if (avctx->extradata_size < 60 + 256 * 3) {
libavcodec/mss12.c:                   "Insufficient extradata size %d for v2\n",
libavcodec/mss12.c:                   avctx->extradata_size);
libavcodec/mss12.c:        c->slice_split = AV_RB32(avctx->extradata + 52);
libavcodec/mss12.c:        c->full_model_syms = AV_RB32(avctx->extradata + 56);
libavcodec/mss12.c:        c->pal[i] = 0xFFU << 24 | AV_RB24(avctx->extradata + 52 +
libavcodec/rscc.c:        if (avctx->extradata && avctx->extradata_size == 4) {
libavcodec/rscc.c:            if ((avctx->extradata[0] >> 1) & 1) {
libavcodec/cook.c: * To use this decoder, a calling application must supply the extradata
libavcodec/cook.c:    ff_dlog(q->avctx, "COOKextradata\n");
libavcodec/cook.c:    /* Take care of the codec specific extradata. */
libavcodec/cook.c:    if (avctx->extradata_size < 8) {
libavcodec/cook.c:        av_log(avctx, AV_LOG_ERROR, "Necessary extradata missing!\n");
libavcodec/cook.c:    av_log(avctx, AV_LOG_DEBUG, "codecdata_length=%d\n", avctx->extradata_size);
libavcodec/cook.c:    bytestream2_init(&gb, avctx->extradata, avctx->extradata_size);
libavcodec/cook.c:        /* Initialize extradata related variables. */
libavcodec/cook.c:            if (avctx->extradata_size >= 16) {
libavcodec/huffyuvenc.c:    avctx->extradata = av_mallocz(3*MAX_N + 4);
libavcodec/huffyuvenc.c:    if (!avctx->extradata)
libavcodec/huffyuvenc.c:    ((uint8_t*)avctx->extradata)[0] = s->predictor | (s->decorrelate << 6);
libavcodec/huffyuvenc.c:    ((uint8_t*)avctx->extradata)[2] = s->interlaced ? 0x10 : 0x20;
libavcodec/huffyuvenc.c:        ((uint8_t*)avctx->extradata)[2] |= 0x40;
libavcodec/huffyuvenc.c:        ((uint8_t*)avctx->extradata)[1] = s->bitstream_bpp;
libavcodec/huffyuvenc.c:        ((uint8_t*)avctx->extradata)[3] = 0;
libavcodec/huffyuvenc.c:        ((uint8_t*)avctx->extradata)[1] = ((s->bps-1)<<4) | s->chroma_h_shift | (s->chroma_v_shift<<2);
libavcodec/huffyuvenc.c:            ((uint8_t*)avctx->extradata)[2] |= s->yuv ? 1 : 2;
libavcodec/huffyuvenc.c:            ((uint8_t*)avctx->extradata)[2] |= 4;
libavcodec/huffyuvenc.c:        ((uint8_t*)avctx->extradata)[3] = 1;
libavcodec/huffyuvenc.c:    s->avctx->extradata_size = 4;
libavcodec/huffyuvenc.c:    ret = store_huffman_tables(s, s->avctx->extradata + s->avctx->extradata_size);
libavcodec/huffyuvenc.c:    s->avctx->extradata_size += ret;
libavcodec/huffyuvenc.c:    av_freep(&avctx->extradata);
libavcodec/trace_headers_bsf.c:    if (bsf->par_in->extradata) {
libavcodec/trace_headers_bsf.c:        err = ff_cbs_read_extradata(ctx->cbc, frag, bsf->par_in);
libavcodec/4xm.c:    if (avctx->extradata_size != 4 || !avctx->extradata) {
libavcodec/4xm.c:        av_log(avctx, AV_LOG_ERROR, "extradata wrong or missing\n");
libavcodec/4xm.c:    f->version = AV_RL32(avctx->extradata) >> 16;
libavcodec/vaapi_encode.c:                   "for extradata: %d.\n", err);
libavcodec/vaapi_encode.c:            avctx->extradata_size = (bit_len + 7) / 8;
libavcodec/vaapi_encode.c:            avctx->extradata = av_mallocz(avctx->extradata_size +
libavcodec/vaapi_encode.c:            if (!avctx->extradata) {
libavcodec/vaapi_encode.c:            memcpy(avctx->extradata, data, avctx->extradata_size);
libavcodec/utvideoenc.c:    /* extradata size is 4 * 32 bits */
libavcodec/utvideoenc.c:    avctx->extradata_size = 16;
libavcodec/utvideoenc.c:    avctx->extradata = av_mallocz(avctx->extradata_size +
libavcodec/utvideoenc.c:    if (!avctx->extradata) {
libavcodec/utvideoenc.c:        av_log(avctx, AV_LOG_ERROR, "Could not allocate extradata.\n");
libavcodec/utvideoenc.c:    AV_WB32(avctx->extradata, MKTAG(1, 0, 0, 0xF0));
libavcodec/utvideoenc.c:    AV_WL32(avctx->extradata + 4, original_format);
libavcodec/utvideoenc.c:    AV_WL32(avctx->extradata + 8, c->frame_info_size);
libavcodec/utvideoenc.c:    AV_WL32(avctx->extradata + 12, c->flags);
libavcodec/mpeg4videodec.c:                return 0; // ordinary return value for parsing of extradata
libavcodec/h264_redundant_pps_bsf.c:    int extradata_pic_init_qp;
libavcodec/h264_redundant_pps_bsf.c:    ctx->current_pic_init_qp = ctx->extradata_pic_init_qp;
libavcodec/aac_adtstoasc_bsf.c:    if (bsfc->par_in->extradata && pkt->size >= 2 && (AV_RB16(pkt->data) >> 4) != 0xfff)
libavcodec/aac_adtstoasc_bsf.c:        uint8_t       *extradata;
libavcodec/aac_adtstoasc_bsf.c:        extradata = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA,
libavcodec/aac_adtstoasc_bsf.c:        if (!extradata) {
libavcodec/aac_adtstoasc_bsf.c:        init_put_bits(&pb, extradata, 2 + pce_size);
libavcodec/aac_adtstoasc_bsf.c:            memcpy(extradata + 2, pce_data, pce_size);
libavcodec/aac_adtstoasc_bsf.c:    /* Validate the extradata if the stream is already MPEG-4 AudioSpecificConfig */
libavcodec/aac_adtstoasc_bsf.c:    if (ctx->par_in->extradata) {
libavcodec/aac_adtstoasc_bsf.c:        int ret = avpriv_mpeg4audio_get_config2(&mp4ac, ctx->par_in->extradata,
libavcodec/aac_adtstoasc_bsf.c:                                                ctx->par_in->extradata_size, 1, ctx);
libavcodec/aac_adtstoasc_bsf.c:            av_log(ctx, AV_LOG_ERROR, "Error parsing AudioSpecificConfig extradata!\n");
libavcodec/qsvenc.c:    mfxExtCodingOptionSPSPPS extradata = {
libavcodec/qsvenc.c:        .Header.BufferSz = sizeof(extradata),
libavcodec/qsvenc.c:    mfxExtCodingOptionVPS extradata_vps = {
libavcodec/qsvenc.c:        .Header.BufferSz = sizeof(extradata_vps),
libavcodec/qsvenc.c:    int ret, ext_buf_num = 0, extradata_offset = 0;
libavcodec/qsvenc.c:    ext_buffers[ext_buf_num++] = (mfxExtBuffer*)&extradata;
libavcodec/qsvenc.c:        ext_buffers[ext_buf_num++] = (mfxExtBuffer*)&extradata_vps;
libavcodec/qsvenc.c:    if (!extradata.SPSBufSize || (need_pps && !extradata.PPSBufSize)
libavcodec/qsvenc.c:        || (q->hevc_vps && !extradata_vps.VPSBufSize)
libavcodec/qsvenc.c:        av_log(avctx, AV_LOG_ERROR, "No extradata returned from libmfx.\n");
libavcodec/qsvenc.c:    avctx->extradata_size = extradata.SPSBufSize + need_pps * extradata.PPSBufSize;
libavcodec/qsvenc.c:    avctx->extradata_size += q->hevc_vps * extradata_vps.VPSBufSize;
libavcodec/qsvenc.c:    avctx->extradata = av_malloc(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/qsvenc.c:    if (!avctx->extradata)
libavcodec/qsvenc.c:        memcpy(avctx->extradata, vps_buf, extradata_vps.VPSBufSize);
libavcodec/qsvenc.c:        extradata_offset += extradata_vps.VPSBufSize;
libavcodec/qsvenc.c:    memcpy(avctx->extradata + extradata_offset, sps_buf, extradata.SPSBufSize);
libavcodec/qsvenc.c:    extradata_offset += extradata.SPSBufSize;
libavcodec/qsvenc.c:        memcpy(avctx->extradata + extradata_offset, pps_buf, extradata.PPSBufSize);
libavcodec/qsvenc.c:        extradata_offset += extradata.PPSBufSize;
libavcodec/qsvenc.c:    memset(avctx->extradata + avctx->extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/bintext.c:    p = avctx->extradata;
libavcodec/bintext.c:        if(avctx->extradata_size < 2 + (!!(s->flags & BINTEXT_PALETTE))*3*16
libavcodec/bintext.c:            av_log(avctx, AV_LOG_ERROR, "not enough extradata\n");
libavcodec/mjpegdec.c:        if ((ret = init_get_bits(&s->gb, avctx->extradata, avctx->extradata_size * 8)) < 0)
libavcodec/mjpegdec.c:        if (avctx->extradata_size >= 4)
libavcodec/mjpegdec.c:            s->smv_frames_per_jpeg = AV_RL32(avctx->extradata);
libavcodec/mjpegdec.c:    } else if (avctx->extradata_size > 8
libavcodec/mjpegdec.c:        && AV_RL32(avctx->extradata) == 0x2C
libavcodec/mjpegdec.c:        && AV_RL32(avctx->extradata+4) == 0x18) {
libavcodec/mjpegdec.c:        parse_avid(s, avctx->extradata, avctx->extradata_size);
libavcodec/vorbis_parser.h: * Allocate and initialize the Vorbis parser using headers in the extradata.
libavcodec/vorbis_parser.h:AVVorbisParseContext *av_vorbis_parse_init(const uint8_t *extradata,
libavcodec/vorbis_parser.h:                                           int extradata_size);
libavcodec/mpegaudiodec_template.c:    if ((avctx->extradata_size < 2) || !avctx->extradata) {
libavcodec/mpegaudiodec_template.c:        av_log(avctx, AV_LOG_ERROR, "Codec extradata missing or too short.\n");
libavcodec/mpegaudiodec_template.c:    avpriv_mpeg4audio_get_config2(&cfg, avctx->extradata,
libavcodec/mpegaudiodec_template.c:                                  avctx->extradata_size, 1, avctx);
libavcodec/libfdk-aacenc.c:    av_freep(&avctx->extradata);
libavcodec/libfdk-aacenc.c:        avctx->extradata_size = info.confSize;
libavcodec/libfdk-aacenc.c:        avctx->extradata      = av_mallocz(avctx->extradata_size +
libavcodec/libfdk-aacenc.c:        if (!avctx->extradata) {
libavcodec/libfdk-aacenc.c:        memcpy(avctx->extradata, info.confBuf, info.confSize);
libavcodec/alsdec.c:    if ((ret = init_get_bits8(&gb, avctx->extradata, avctx->extradata_size)) < 0)
libavcodec/alsdec.c:    config_offset = avpriv_mpeg4audio_get_config2(&m4ac, avctx->extradata,
libavcodec/alsdec.c:                                                  avctx->extradata_size, 1, avctx);
libavcodec/alsdec.c:    if (!avctx->extradata) {
libavcodec/alsdec.c:        av_log(avctx, AV_LOG_ERROR, "Missing required ALS extradata.\n");
libavcodec/rv10.c:    rpr_max = s->avctx->extradata[1] & 7;
libavcodec/rv10.c:            if (s->avctx->extradata_size < 8 + 2 * f) {
libavcodec/rv10.c:            new_w = 4 * ((uint8_t *) s->avctx->extradata)[6 + 2 * f];
libavcodec/rv10.c:            new_h = 4 * ((uint8_t *) s->avctx->extradata)[7 + 2 * f];
libavcodec/rv10.c:    if (avctx->extradata_size < 8) {
libavcodec/rv10.c:    s->h263_long_vectors = ((uint8_t *) avctx->extradata)[3] & 1;
libavcodec/rv10.c:    rv->sub_id           = AV_RB32((uint8_t *) avctx->extradata + 4);
libavcodec/rv10.c:               ((uint32_t *) avctx->extradata)[0]);
libavcodec/mvcdec.c:    s->vflip = avctx->extradata_size >= 9 &&
libavcodec/mvcdec.c:               !memcmp(avctx->extradata + avctx->extradata_size - 9, "BottomUp", 9);
libavcodec/dfa.c:    int version = avctx->extradata_size==2 ? AV_RL16(avctx->extradata) : 0;
libavcodec/movtextdec.c:    const uint8_t *tx3g_ptr = avctx->extradata;
libavcodec/movtextdec.c:    int i, j = -1, font_length, remaining = avctx->extradata_size - BOX_SIZE_INITIAL;
libavcodec/qdmc.c:    if (!avctx->extradata || (avctx->extradata_size < 48)) {
libavcodec/qdmc.c:        av_log(avctx, AV_LOG_ERROR, "extradata missing or truncated\n");
libavcodec/qdmc.c:    bytestream2_init(&b, avctx->extradata, avctx->extradata_size);
libavcodec/qdmc.c:        av_log(avctx, AV_LOG_ERROR, "not enough extradata (%i)\n",
libavcodec/qdmc.c:        av_log(avctx, AV_LOG_ERROR, "extradata size too small, %i < %i\n",
libavcodec/qdmc.c:        av_log(avctx, AV_LOG_ERROR, "invalid extradata, expecting QDCA\n");
libavcodec/codec_par.h:     * avcodec_parameters_free(). The allocated size of extradata must be at
libavcodec/codec_par.h:     * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
libavcodec/codec_par.h:    uint8_t *extradata;
libavcodec/codec_par.h:     * Size of the extradata content in bytes.
libavcodec/codec_par.h:    int      extradata_size;
libavcodec/packet.h:     * that the extradata buffer was changed and the receiving side should
libavcodec/packet.h:     * act upon it appropriately. The new extradata is embedded in the side
libavcodec/ralf.c:    if (avctx->extradata_size < 24 || memcmp(avctx->extradata, "LSD:", 4)) {
libavcodec/ralf.c:    ctx->version = AV_RB16(avctx->extradata + 4);
libavcodec/ralf.c:    avctx->channels    = AV_RB16(avctx->extradata + 8);
libavcodec/ralf.c:    avctx->sample_rate = AV_RB32(avctx->extradata + 12);
libavcodec/ralf.c:    ctx->max_frame_size = AV_RB32(avctx->extradata + 16);
libavcodec/options.c:    av_freep(&avctx->extradata);
libavcodec/options.c:    av_freep(&avctx->extradata);
libavcodec/options.c:    avctx->extradata_size = 0;
libavcodec/options.c:    dest->extradata       = NULL;
libavcodec/options.c:    alloc_and_copy_or_fail(extradata,    src->extradata_size,
libavcodec/options.c:    dest->extradata_size  = src->extradata_size;
libavcodec/libaomenc.c:        const AVBitStreamFilter *filter = av_bsf_get_by_name("extract_extradata");
libavcodec/libaomenc.c:            av_log(avctx, AV_LOG_ERROR, "extract_extradata bitstream filter "
libavcodec/libaomenc.c:            av_log(avctx, AV_LOG_ERROR, "extract_extradata filter "
libavcodec/libaomenc.c:            av_log(avctx, AV_LOG_ERROR, "extract_extradata filter "
libavcodec/h264_parse.h:int ff_h264_decode_extradata(const uint8_t *data, int size, H264ParamSets *ps,
libavcodec/avcodec.h: * Place global headers in extradata instead of every keyframe.
libavcodec/avcodec.h: * Place global headers at every keyframe instead of in extradata.
libavcodec/avcodec.h:     * some codecs need / can use extradata like Huffman tables.
libavcodec/avcodec.h:     * than extradata_size to avoid problems if it is read with the bitstream reader.
libavcodec/avcodec.h:     * The bytewise contents of extradata must not depend on the architecture or CPU endianness.
libavcodec/avcodec.h:    uint8_t *extradata;
libavcodec/avcodec.h:    int extradata_size;
libavcodec/avcodec.h: * @deprecated Use dump_extradata, remove_extra or extract_extradata
libavcodec/avcodec.h: * Encode extradata length to a buffer. Used by xiph codecs.
libavcodec/avcodec.h: * @param v size of extradata in bytes
libavcodec/Makefile:OBJS-$(CONFIG_DUMP_EXTRADATA_BSF)         += dump_extradata_bsf.o
libavcodec/Makefile:OBJS-$(CONFIG_EXTRACT_EXTRADATA_BSF)      += extract_extradata_bsf.o    \
libavcodec/Makefile:OBJS-$(CONFIG_REMOVE_EXTRADATA_BSF)       += remove_extradata_bsf.o
libavcodec/codec2utils.h:static inline void codec2_make_extradata(uint8_t *ptr, int mode) {
libavcodec/codec2utils.h:static inline uint8_t codec2_mode_from_extradata(uint8_t *ptr) {
libavcodec/extract_extradata_bsf.c:static int extract_extradata_av1(AVBSFContext *ctx, AVPacket *pkt,
libavcodec/extract_extradata_bsf.c:    static const int extradata_obu_types[] = {
libavcodec/extract_extradata_bsf.c:    int extradata_size = 0, filtered_size = 0;
libavcodec/extract_extradata_bsf.c:    int nb_extradata_obu_types = FF_ARRAY_ELEMS(extradata_obu_types);
libavcodec/extract_extradata_bsf.c:        if (val_in_array(extradata_obu_types, nb_extradata_obu_types, obu->type)) {
libavcodec/extract_extradata_bsf.c:            extradata_size += obu->raw_size;
libavcodec/extract_extradata_bsf.c:    if (extradata_size && has_seq) {
libavcodec/extract_extradata_bsf.c:        PutByteContext pb_filtered_data, pb_extradata;
libavcodec/extract_extradata_bsf.c:        uint8_t *extradata;
libavcodec/extract_extradata_bsf.c:        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/extract_extradata_bsf.c:        if (!extradata) {
libavcodec/extract_extradata_bsf.c:        *data = extradata;
libavcodec/extract_extradata_bsf.c:        *size = extradata_size;
libavcodec/extract_extradata_bsf.c:        bytestream2_init_writer(&pb_extradata, extradata, extradata_size);
libavcodec/extract_extradata_bsf.c:            if (val_in_array(extradata_obu_types, nb_extradata_obu_types,
libavcodec/extract_extradata_bsf.c:                bytestream2_put_bufferu(&pb_extradata, obu->raw_data, obu->raw_size);
libavcodec/extract_extradata_bsf.c:static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,
libavcodec/extract_extradata_bsf.c:    static const int extradata_nal_types_hevc[] = {
libavcodec/extract_extradata_bsf.c:    static const int extradata_nal_types_h264[] = {
libavcodec/extract_extradata_bsf.c:    int extradata_size = 0, filtered_size = 0;
libavcodec/extract_extradata_bsf.c:    const int *extradata_nal_types;
libavcodec/extract_extradata_bsf.c:    int nb_extradata_nal_types;
libavcodec/extract_extradata_bsf.c:        extradata_nal_types    = extradata_nal_types_hevc;
libavcodec/extract_extradata_bsf.c:        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);
libavcodec/extract_extradata_bsf.c:        extradata_nal_types    = extradata_nal_types_h264;
libavcodec/extract_extradata_bsf.c:        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);
libavcodec/extract_extradata_bsf.c:        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {
libavcodec/extract_extradata_bsf.c:            extradata_size += nal->raw_size + 3;
libavcodec/extract_extradata_bsf.c:    if (extradata_size &&
libavcodec/extract_extradata_bsf.c:        PutByteContext pb_filtered_data, pb_extradata;
libavcodec/extract_extradata_bsf.c:        uint8_t *extradata;
libavcodec/extract_extradata_bsf.c:        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/extract_extradata_bsf.c:        if (!extradata) {
libavcodec/extract_extradata_bsf.c:        *data = extradata;
libavcodec/extract_extradata_bsf.c:        *size = extradata_size;
libavcodec/extract_extradata_bsf.c:        bytestream2_init_writer(&pb_extradata, extradata, extradata_size);
libavcodec/extract_extradata_bsf.c:            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,
libavcodec/extract_extradata_bsf.c:                bytestream2_put_be24u(&pb_extradata, 1); //startcode
libavcodec/extract_extradata_bsf.c:                bytestream2_put_bufferu(&pb_extradata, nal->raw_data, nal->raw_size);
libavcodec/extract_extradata_bsf.c:static int extract_extradata_vc1(AVBSFContext *ctx, AVPacket *pkt,
libavcodec/extract_extradata_bsf.c:    int has_extradata = 0, extradata_size = 0;
libavcodec/extract_extradata_bsf.c:            has_extradata = 1;
libavcodec/extract_extradata_bsf.c:        } else if (has_extradata && IS_MARKER(state)) {
libavcodec/extract_extradata_bsf.c:            extradata_size = ptr - 4 - pkt->data;
libavcodec/extract_extradata_bsf.c:    if (extradata_size) {
libavcodec/extract_extradata_bsf.c:        *data = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/extract_extradata_bsf.c:        memcpy(*data, pkt->data, extradata_size);
libavcodec/extract_extradata_bsf.c:        *size = extradata_size;
libavcodec/extract_extradata_bsf.c:            pkt->data += extradata_size;
libavcodec/extract_extradata_bsf.c:            pkt->size -= extradata_size;
libavcodec/extract_extradata_bsf.c:static int extract_extradata_mpeg12(AVBSFContext *ctx, AVPacket *pkt,
libavcodec/extract_extradata_bsf.c:static int extract_extradata_mpeg4(AVBSFContext *ctx, AVPacket *pkt,
libavcodec/extract_extradata_bsf.c:    { AV_CODEC_ID_AV1,        extract_extradata_av1     },
libavcodec/extract_extradata_bsf.c:    { AV_CODEC_ID_AVS2,       extract_extradata_mpeg4   },
libavcodec/extract_extradata_bsf.c:    { AV_CODEC_ID_CAVS,       extract_extradata_mpeg4   },
libavcodec/extract_extradata_bsf.c:    { AV_CODEC_ID_H264,       extract_extradata_h2645   },
libavcodec/extract_extradata_bsf.c:    { AV_CODEC_ID_HEVC,       extract_extradata_h2645   },
libavcodec/extract_extradata_bsf.c:    { AV_CODEC_ID_MPEG1VIDEO, extract_extradata_mpeg12  },
libavcodec/extract_extradata_bsf.c:    { AV_CODEC_ID_MPEG2VIDEO, extract_extradata_mpeg12  },
libavcodec/extract_extradata_bsf.c:    { AV_CODEC_ID_MPEG4,      extract_extradata_mpeg4   },
libavcodec/extract_extradata_bsf.c:    { AV_CODEC_ID_VC1,        extract_extradata_vc1     },
libavcodec/extract_extradata_bsf.c:static int extract_extradata_init(AVBSFContext *ctx)
libavcodec/extract_extradata_bsf.c:static int extract_extradata_filter(AVBSFContext *ctx, AVPacket *pkt)
libavcodec/extract_extradata_bsf.c:    uint8_t *extradata = NULL;
libavcodec/extract_extradata_bsf.c:    int extradata_size;
libavcodec/extract_extradata_bsf.c:    ret = s->extract(ctx, pkt, &extradata, &extradata_size);
libavcodec/extract_extradata_bsf.c:    if (extradata) {
libavcodec/extract_extradata_bsf.c:        memset(extradata + extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
libavcodec/extract_extradata_bsf.c:                                      extradata, extradata_size);
libavcodec/extract_extradata_bsf.c:            av_freep(&extradata);
libavcodec/extract_extradata_bsf.c:static void extract_extradata_close(AVBSFContext *ctx)
libavcodec/extract_extradata_bsf.c:    { "remove", "remove the extradata from the bitstream", OFFSET(remove), AV_OPT_TYPE_INT,
libavcodec/extract_extradata_bsf.c:static const AVClass extract_extradata_class = {
libavcodec/extract_extradata_bsf.c:    .class_name = "extract_extradata",
libavcodec/extract_extradata_bsf.c:const AVBitStreamFilter ff_extract_extradata_bsf = {
libavcodec/extract_extradata_bsf.c:    .name           = "extract_extradata",
libavcodec/extract_extradata_bsf.c:    .priv_class     = &extract_extradata_class,
libavcodec/extract_extradata_bsf.c:    .init           = extract_extradata_init,
libavcodec/extract_extradata_bsf.c:    .filter         = extract_extradata_filter,
libavcodec/extract_extradata_bsf.c:    .close          = extract_extradata_close,
libavcodec/libvorbisdec.c:    uint8_t *p= avccontext->extradata;
libavcodec/libvorbisdec.c:    unsigned char *headers[3], *extradata = avccontext->extradata;
libavcodec/libvorbisdec.c:    if(! avccontext->extradata_size || ! p) {
libavcodec/libvorbisdec.c:        av_log(avccontext, AV_LOG_ERROR, "vorbis extradata absent\n");
libavcodec/libvorbisdec.c:            if (sizesum > avccontext->extradata_size) {
libavcodec/libvorbisdec.c:                av_log(avccontext, AV_LOG_ERROR, "vorbis extradata too small\n");
libavcodec/libvorbisdec.c:            while((*p == 0xFF) && (sizesum < avccontext->extradata_size)) {
libavcodec/libvorbisdec.c:            if(sizesum > avccontext->extradata_size) {
libavcodec/libvorbisdec.c:        hsizes[2] = avccontext->extradata_size - hsizes[0]-hsizes[1]-offset;
libavcodec/libvorbisdec.c:               "vorbis header sizes: %d, %d, %d, / extradata_len is %d \n",
libavcodec/libvorbisdec.c:               hsizes[0], hsizes[1], hsizes[2], avccontext->extradata_size);
libavcodec/libvorbisdec.c:        headers[0] = extradata + offset;
libavcodec/libvorbisdec.c:        headers[1] = extradata + offset + hsizes[0];
libavcodec/libvorbisdec.c:        headers[2] = extradata + offset + hsizes[0] + hsizes[1];
libavcodec/hevcdec.c:static int hevc_decode_extradata(HEVCContext *s, uint8_t *buf, int length, int first)
libavcodec/hevcdec.c:    ret = ff_hevc_decode_extradata(buf, length, &s->ps, &s->sei, &s->is_nalff,
libavcodec/hevcdec.c:    buffer_size_t new_extradata_size;
libavcodec/hevcdec.c:    uint8_t *new_extradata;
libavcodec/hevcdec.c:    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,
libavcodec/hevcdec.c:                                            &new_extradata_size);
libavcodec/hevcdec.c:    if (new_extradata && new_extradata_size > 0) {
libavcodec/hevcdec.c:        ret = hevc_decode_extradata(s, new_extradata, new_extradata_size, 0);
libavcodec/hevcdec.c:        if (avctx->extradata_size > 0 && avctx->extradata) {
libavcodec/hevcdec.c:            ret = hevc_decode_extradata(s, avctx->extradata, avctx->extradata_size, 1);
libavcodec/adpcm.c:        if (avctx->extradata && avctx->extradata_size >= 8) {
libavcodec/adpcm.c:            c->status[0].predictor = av_clip_intp2(AV_RL32(avctx->extradata    ), 18);
libavcodec/adpcm.c:            c->status[1].predictor = av_clip_intp2(AV_RL32(avctx->extradata + 4), 18);
libavcodec/adpcm.c:        if (avctx->extradata) {
libavcodec/adpcm.c:            if (avctx->extradata_size >= 28) {
libavcodec/adpcm.c:                c->status[0].predictor  = av_clip_intp2(AV_RL32(avctx->extradata + 16), 18);
libavcodec/adpcm.c:                c->status[0].step_index = av_clip(AV_RL32(avctx->extradata + 20), 0, 88);
libavcodec/adpcm.c:                c->status[1].predictor  = av_clip_intp2(AV_RL32(avctx->extradata + 4), 18);
libavcodec/adpcm.c:                c->status[1].step_index = av_clip(AV_RL32(avctx->extradata + 8), 0, 88);
libavcodec/adpcm.c:            } else if (avctx->extradata_size >= 16) {
libavcodec/adpcm.c:                c->status[0].predictor  = av_clip_intp2(AV_RL32(avctx->extradata +  0), 18);
libavcodec/adpcm.c:                c->status[0].step_index = av_clip(AV_RL32(avctx->extradata +  4), 0, 88);
libavcodec/adpcm.c:                c->status[1].predictor  = av_clip_intp2(AV_RL32(avctx->extradata +  8), 18);
libavcodec/adpcm.c:                c->status[1].step_index = av_clip(AV_RL32(avctx->extradata + 12), 0, 88);
libavcodec/adpcm.c:        if (avctx->extradata && avctx->extradata_size >= 2)
libavcodec/adpcm.c:            c->vqa_version = AV_RL16(avctx->extradata);
libavcodec/adpcm.c:        if (avctx->extradata) {
libavcodec/adpcm.c:        if (avctx->extradata && avctx->extradata_size == 1 && avctx->extradata[0]) {
libavcodec/adpcm.c:            samples_per_block = avctx->extradata[0] / 16;
libavcodec/adpcm.c:            blocks = nb_samples / avctx->extradata[0];
libavcodec/adpcm.c:        if (avctx->extradata) {
libavcodec/adpcm.c:            if (avctx->extradata_size < 32 * avctx->channels) {
libavcodec/adpcm.c:            bytestream2_init(&tb, avctx->extradata, avctx->extradata_size);
libavdevice/vfwcap.c:            par->extradata = av_malloc(9 + AV_INPUT_BUFFER_PADDING_SIZE);
libavdevice/vfwcap.c:            if (par->extradata) {
libavdevice/vfwcap.c:                par->extradata_size = 9;
libavdevice/vfwcap.c:                memcpy(par->extradata, "BottomUp", 9);
libavdevice/dshow.c:                    par->extradata = av_malloc(9 + AV_INPUT_BUFFER_PADDING_SIZE);
libavdevice/dshow.c:                    if (par->extradata) {
libavdevice/dshow.c:                        par->extradata_size = 9;
libavdevice/dshow.c:                        memcpy(par->extradata, "BottomUp", 9);
libavfilter/vf_subtitles.c:                             st->codecpar->extradata,
libavfilter/vf_subtitles.c:                             st->codecpar->extradata_size);
libavformat/oggparsespeex.c:        if ((ret = ff_alloc_extradata(st->codecpar, os->psize)) < 0)
libavformat/oggparsespeex.c:        memcpy(st->codecpar->extradata, p, st->codecpar->extradata_size);
libavformat/ape.c:    if ((ret = ff_alloc_extradata(st->codecpar, APE_EXTRADATA_SIZE)) < 0)
libavformat/ape.c:    AV_WL16(st->codecpar->extradata + 0, ape->fileversion);
libavformat/ape.c:    AV_WL16(st->codecpar->extradata + 2, ape->compressiontype);
libavformat/ape.c:    AV_WL16(st->codecpar->extradata + 4, ape->formatflags);
libavformat/latmenc.c:static int latm_decode_extradata(AVFormatContext *s, uint8_t *buf, int size)
libavformat/latmenc.c:    if (par->extradata_size > 0 &&
libavformat/latmenc.c:        latm_decode_extradata(s, par->extradata, par->extradata_size) < 0)
libavformat/latmenc.c:            header_size = (par->extradata_size - (ctx->off >> 3)) * 8;
libavformat/latmenc.c:            copy_bits(bs, &par->extradata[ctx->off >> 3], header_size);
libavformat/latmenc.c:            copy_bits(bs, par->extradata, ctx->off + 3);
libavformat/latmenc.c:                int ret = init_get_bits8(&gb, par->extradata, par->extradata_size);
libavformat/latmenc.c:                av_assert0(ret >= 0); // extradata size has been checked already, so this should not fail
libavformat/latmenc.c:    if (!par->extradata) {
libavformat/latmenc.c:                if (latm_decode_extradata(s, side_data, side_data_size) < 0)
libavformat/latmenc.c:                ret = ff_alloc_extradata(par, side_data_size);
libavformat/latmenc.c:                memcpy(par->extradata, side_data, side_data_size);
libavformat/rtpdec_hevc.c:            par->extradata_size = hevc_data->vps_size + hevc_data->sps_size +
libavformat/rtpdec_hevc.c:            if ((ret = ff_alloc_extradata(par, par->extradata_size)) >= 0) {
libavformat/rtpdec_hevc.c:                memcpy(par->extradata + pos, hevc_data->vps, hevc_data->vps_size);
libavformat/rtpdec_hevc.c:                memcpy(par->extradata + pos, hevc_data->sps, hevc_data->sps_size);
libavformat/rtpdec_hevc.c:                memcpy(par->extradata + pos, hevc_data->pps, hevc_data->pps_size);
libavformat/rtpdec_hevc.c:                memcpy(par->extradata + pos, hevc_data->sei, hevc_data->sei_size);
libavformat/mpeg.c:        ret = ff_alloc_extradata(par, header.len);
libavformat/mpeg.c:        memcpy(par->extradata, header.str, header.len);
libavformat/hevc.h: * Writes HEVC extradata (parameter sets, declarative SEI NAL units) to the
libavformat/hevc.h: * If the extradata is Annex B format, it gets converted to hvcC format before
libavformat/oggparsecelt.c:        ret = ff_alloc_extradata(st->codecpar, 2 * sizeof(uint32_t));
libavformat/oggparsecelt.c:        AV_WL32(st->codecpar->extradata + 0, overlap);
libavformat/oggparsecelt.c:        AV_WL32(st->codecpar->extradata + 4, version);
libavformat/nistspheredec.c:                if (ff_alloc_extradata(st->codecpar, 1))
libavformat/nistspheredec.c:                    st->codecpar->extradata[0] = 1;
libavformat/ttaenc.c:    if (par->extradata && par->extradata_size < 22) {
libavformat/ttaenc.c:        av_log(s, AV_LOG_ERROR, "Invalid TTA extradata\n");
libavformat/ttaenc.c:    /* Ignore most extradata information if present. It can be innacurate
libavformat/ttaenc.c:    avio_wl16(s->pb, par->extradata ? AV_RL16(par->extradata + 4) : 1);
libavformat/concatdec.c:        if (st->codecpar->extradata_size < source_st->codecpar->extradata_size) {
libavformat/concatdec.c:            ret = ff_alloc_extradata(st->codecpar,
libavformat/concatdec.c:                                     source_st->codecpar->extradata_size);
libavformat/concatdec.c:        memcpy(st->codecpar->extradata, source_st->codecpar->extradata,
libavformat/concatdec.c:               source_st->codecpar->extradata_size);
libavformat/concatdec.c:        if (!st->codecpar->extradata_size                                                ||
libavformat/concatdec.c:            (st->codecpar->extradata_size >= 3 && AV_RB24(st->codecpar->extradata) == 1) ||
libavformat/concatdec.c:            (st->codecpar->extradata_size >= 4 && AV_RB32(st->codecpar->extradata) == 1))
libavformat/oggparseogm.c:                if ((ret = ff_alloc_extradata(st->codecpar, size)) < 0)
libavformat/oggparseogm.c:                bytestream2_get_buffer(&p, st->codecpar->extradata, st->codecpar->extradata_size);
libavformat/flacenc_header.c:int ff_flac_write_header(AVIOContext *pb, const uint8_t *extradata,
libavformat/flacenc_header.c:                         int extradata_size, int last_block)
libavformat/flacenc_header.c:    if (extradata_size < FLAC_STREAMINFO_SIZE)
libavformat/flacenc_header.c:    avio_write(pb, extradata, FLAC_STREAMINFO_SIZE);
libavformat/jacosubenc.c:    if (par->extradata_size) {
libavformat/jacosubenc.c:        avio_write(s->pb, par->extradata, par->extradata_size - 1);
libavformat/rtpdec_svq3.c:        if (len < 2 || ff_alloc_extradata(st->codecpar, len + 8))
libavformat/rtpdec_svq3.c:        memcpy(st->codecpar->extradata, "SEQH", 4);
libavformat/rtpdec_svq3.c:        AV_WB32(st->codecpar->extradata + 4, len);
libavformat/rtpdec_svq3.c:        memcpy(st->codecpar->extradata + 8, buf, len);
libavformat/rtpdec_svq3.c:         * delay decoder initialization since extradata is
libavformat/flic.c:    if ((ret = ff_alloc_extradata(st->codecpar, FLIC_HEADER_SIZE)) < 0)
libavformat/flic.c:    memcpy(st->codecpar->extradata, header, FLIC_HEADER_SIZE);
libavformat/flic.c:        ast->codecpar->extradata_size = 0;
libavformat/flic.c:        if ((ret = ff_alloc_extradata(st->codecpar, 12)) < 0)
libavformat/flic.c:        memcpy(st->codecpar->extradata, header, 12);
libavformat/takdec.c:            if (st->codecpar->extradata)
libavformat/takdec.c:            st->codecpar->extradata             = buffer;
libavformat/takdec.c:            st->codecpar->extradata_size        = size - 3;
libavformat/idcin.c:    /* load up the Huffman tables into extradata */
libavformat/idcin.c:    if ((ret = ff_get_extradata(s, st->codecpar, pb, HUFFMAN_TABLE_SIZE)) < 0)
libavformat/bfi.c:    /*Load the palette to extradata */
libavformat/bfi.c:    ret = ff_get_extradata(s, vstream->codecpar, pb, 768);
libavformat/oggparsevorbis.c:        ret = fixup_vorbis_headers(s, priv, &st->codecpar->extradata);
libavformat/oggparsevorbis.c:            st->codecpar->extradata_size = 0;
libavformat/oggparsevorbis.c:        st->codecpar->extradata_size = ret;
libavformat/oggparsevorbis.c:        priv->vp = av_vorbis_parse_init(st->codecpar->extradata, st->codecpar->extradata_size);
libavformat/oggparsevorbis.c:            av_freep(&st->codecpar->extradata);
libavformat/oggparsevorbis.c:            st->codecpar->extradata_size = 0;
libavformat/mpc8.c:    if ((ret = ff_get_extradata(s, st->codecpar, pb, 2)) < 0)
libavformat/mpc8.c:    st->codecpar->channels = (st->codecpar->extradata[1] >> 4) + 1;
libavformat/mpc8.c:    st->codecpar->sample_rate = mpc8_rate[st->codecpar->extradata[0] >> 5];
libavformat/mpc8.c:    avpriv_set_pts_info(st, 64, 1152  << (st->codecpar->extradata[1]&3)*2, st->codecpar->sample_rate);
libavformat/mpc8.c:    st->duration = c->samples / (1152 << (st->codecpar->extradata[1]&3)*2);
libavformat/riffdec.c:            if (ff_get_extradata(s, par, pb, cbSize) < 0)
libavformat/riffdec.c:        if (ff_get_extradata(s, par, pb, size) < 0)
libavformat/riffdec.c:        nb_streams         = AV_RL16(par->extradata + 4);
libavformat/riffdec.c:        par->sample_rate   = AV_RL32(par->extradata + 12);
libavformat/riffdec.c:            par->channels += par->extradata[8 + i * 20 + 17];
libavformat/aiffenc.c:        || par->codec_tag == MKTAG('Q','c','l','p')) && par->extradata_size) {
libavformat/aiffenc.c:        avio_wb32(pb, par->extradata_size);
libavformat/aiffenc.c:        avio_write(pb, par->extradata, par->extradata_size);
libavformat/yop.c:    ret = ff_get_extradata(s, video_par, pb, 8);
libavformat/yop.c:    yop->palette_size       = video_par->extradata[0] * 3 + 4;
libavformat/yop.c:    yop->audio_block_length = AV_RL16(video_par->extradata + 6);
libavformat/vc1testenc.c:    avio_write(pb, par->extradata, 4);
libavformat/framecrcenc.c:        if (par->extradata) {
libavformat/framecrcenc.c:            uint32_t crc = av_adler32_update(0, par->extradata, par->extradata_size);
libavformat/framecrcenc.c:            avio_printf(s->pb, "#extradata %d: %8d, 0x%08"PRIx32"\n",
libavformat/framecrcenc.c:                        i, par->extradata_size, crc);
libavformat/rtpdec.c:static int opus_write_extradata(AVCodecParameters *codecpar)
libavformat/rtpdec.c:    /* This function writes an extradata with a channel mapping family of 0.
libavformat/rtpdec.c:    ret = ff_alloc_extradata(codecpar, 19);
libavformat/rtpdec.c:    bs = (uint8_t *)codecpar->extradata;
libavformat/rtpdec.c:            ret = opus_write_extradata(st->codecpar);
libavformat/rtpdec.c:                       "Error creating opus extradata: %s\n",
libavformat/mpc.c:    if ((ret = ff_get_extradata(s, st->codecpar, s->pb, 16)) < 0)
libavformat/mpc.c:    st->codecpar->sample_rate = mpc_rate[st->codecpar->extradata[2] & 3];
libavformat/apetag.c:            if ((ret = ff_get_extradata(s, st->codecpar, s->pb, size)) < 0)
libavformat/flacenc.h:int ff_flac_write_header(AVIOContext *pb, const uint8_t *extradata,
libavformat/flacenc.h:                         int extradata_size, int last_block);
libavformat/bink.c:    if ((ret = ff_get_extradata(s, vst->codecpar, pb, 4)) < 0)
libavformat/bink.c:            if ((ret = ff_alloc_extradata(ast->codecpar, 4)) < 0)
libavformat/bink.c:            AV_WL32(ast->codecpar->extradata, vst->codecpar->codec_tag);
libavformat/movenc.c: * This function writes extradata "as is".
libavformat/movenc.c:static int mov_write_extradata_tag(AVIOContext *pb, MOVTrack *track)
libavformat/movenc.c:    avio_write(pb, track->par->extradata, track->par->extradata_size);
libavformat/movenc.c:    return track->par->extradata_size;
libavformat/movenc.c:    if (track->par->extradata_size != FLAC_STREAMINFO_SIZE)
libavformat/movenc.c:    avio_wb24(pb, track->par->extradata_size); /* Length */
libavformat/movenc.c:    avio_write(pb, track->par->extradata, track->par->extradata_size); /* BlockData[Length] */
libavformat/movenc.c:    if (track->par->extradata_size < 19) {
libavformat/movenc.c:        av_log(s, AV_LOG_ERROR, "invalid extradata size\n");
libavformat/movenc.c:    /* extradata contains an Ogg OpusHead, other than byte-ordering and
libavformat/movenc.c:    avio_w8(pb, AV_RB8(track->par->extradata + 9)); /* OuputChannelCount */
libavformat/movenc.c:    avio_wb16(pb, AV_RL16(track->par->extradata + 10)); /* PreSkip */
libavformat/movenc.c:    avio_wb32(pb, AV_RL32(track->par->extradata + 12)); /* InputSampleRate */
libavformat/movenc.c:    avio_wb16(pb, AV_RL16(track->par->extradata + 16)); /* OutputGain */
libavformat/movenc.c:    avio_write(pb, track->par->extradata + 18, track->par->extradata_size - 18);
libavformat/movenc.c:        mov_write_extradata_tag(pb, track);
libavformat/movenc.c:        ret = mov_write_extradata_tag(pb, track);
libavformat/movenc.c:    if (track->par->extradata_size >= 12 &&
libavformat/movenc.c:        !memcmp(&track->par->extradata[4], "DpxE", 4)) {
libavformat/movenc.c:        avio_wb32(pb, track->par->extradata[11]);
libavformat/movenc.c:    else if (track->par->extradata_size)
libavformat/movenc.c:        avio_write(pb, track->par->extradata, track->par->extradata_size);
libavformat/movenc.c:        mov_write_extradata_tag(pb, track);
libavformat/movenc.c:        /* Don't write any potential extradata here - the cropping
libavformat/movenc.c:    if (track->par->extradata_size)
libavformat/movenc.c:        avio_write(pb, track->par->extradata, track->par->extradata_size);
libavformat/movenc.c:                int size = track->par->extradata_size;
libavformat/movenc.c:                if (!ff_avc_write_annexb_extradata(track->par->extradata, &ptr,
libavformat/movenc.c:                                    ptr ? ptr : track->par->extradata,
libavformat/movenc.c:                param_write_hex(pb, "CodecPrivateData", track->par->extradata,
libavformat/movenc.c:                                track->par->extradata_size);
libavformat/movenc.c:            param_write_hex(pb, "CodecPrivateData", track->par->extradata,
libavformat/movenc.c:                            track->par->extradata_size);
libavformat/movenc.c:    /* copy extradata if it exists */
libavformat/movenc.c:    if (trk->vos_len == 0 && par->extradata_size > 0 &&
libavformat/movenc.c:        trk->vos_len  = par->extradata_size;
libavformat/movenc.c:        memcpy(trk->vos_data, par->extradata, trk->vos_len);
libavformat/movenc.c:        /* extradata is Annex B, assume the bitstream is too and convert it */
libavformat/movenc.c:            if (par->codec_id == AV_CODEC_ID_H264 && par->extradata_size > 4) {
libavformat/movenc.c:                int nal_size_length = (par->extradata[4] & 0x3) + 1;
libavformat/movenc.c:        if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {
libavformat/movenc.c:            av_free(par->extradata);
libavformat/movenc.c:            par->extradata = newextra;
libavformat/movenc.c:            memcpy(par->extradata, side, side_size);
libavformat/movenc.c:            par->extradata_size = side_size;
libavformat/movenc.c:                mov->need_rewrite_extradata = 1;
libavformat/movenc.c:    if (ff_alloc_extradata(track->par, sizeof(chapter_properties)))
libavformat/movenc.c:    memcpy(track->par->extradata, chapter_properties, sizeof(chapter_properties));
libavformat/movenc.c:            track->par->extradata = buf;
libavformat/movenc.c:            track->par->extradata_size = size;
libavformat/movenc.c:    char *cur = st->codecpar->extradata;
libavformat/movenc.c:        /* copy extradata if it exists */
libavformat/movenc.c:        if (st->codecpar->extradata_size) {
libavformat/movenc.c:                track->vos_len  = st->codecpar->extradata_size;
libavformat/movenc.c:                memcpy(track->vos_data, st->codecpar->extradata, track->vos_len);
libavformat/movenc.c:    if (mov->need_rewrite_extradata) {
libavformat/movenc.c:            track->vos_len  = par->extradata_size;
libavformat/movenc.c:            memcpy(track->vos_data, par->extradata, track->vos_len);
libavformat/movenc.c:        mov->need_rewrite_extradata = 0;
libavformat/segment.c:    if (!st->codecpar->extradata_size) {
libavformat/segment.c:        buffer_size_t pkt_extradata_size;
libavformat/segment.c:        uint8_t *pkt_extradata = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &pkt_extradata_size);
libavformat/segment.c:        if (pkt_extradata && pkt_extradata_size > 0) {
libavformat/segment.c:            ret = ff_alloc_extradata(st->codecpar, pkt_extradata_size);
libavformat/segment.c:                av_log(s, AV_LOG_WARNING, "Unable to add extradata to stream. Output segments may be invalid.\n");
libavformat/segment.c:            memcpy(st->codecpar->extradata, pkt_extradata, pkt_extradata_size);
libavformat/xwma.c:        /* xWMA shouldn't have extradata. But the WMA codecs require it,
libavformat/xwma.c:         * so we provide our own fake extradata.
libavformat/xwma.c:         * First, check that there really was no extradata in the header. If
libavformat/xwma.c:        if (st->codecpar->extradata_size != 0) {
libavformat/xwma.c:            /* Surprise, surprise: We *did* get some extradata. No idea
libavformat/xwma.c:            avpriv_request_sample(s, "Unexpected extradata (%d bytes)",
libavformat/xwma.c:                                  st->codecpar->extradata_size);
libavformat/xwma.c:            if ((ret = ff_alloc_extradata(st->codecpar, 18)) < 0)
libavformat/xwma.c:            memset(st->codecpar->extradata, 0, st->codecpar->extradata_size);
libavformat/xwma.c:            st->codecpar->extradata[ 0] = st->codecpar->bits_per_coded_sample;
libavformat/xwma.c:            st->codecpar->extradata[14] = 224;
libavformat/xwma.c:            if ((ret = ff_alloc_extradata(st->codecpar, 6)) < 0)
libavformat/xwma.c:            memset(st->codecpar->extradata, 0, st->codecpar->extradata_size);
libavformat/xwma.c:            /* setup extradata with our experimentally obtained value */
libavformat/xwma.c:            st->codecpar->extradata[4] = 31;
libavformat/mca.c:    ret = ff_alloc_extradata(st->codecpar, 32 * par->channels);
libavformat/mca.c:        if ((ret = ffio_read_size(s->pb, par->extradata + ch * 32, 32)) < 0)
libavformat/rtpdec_h264.c:                       "Unable to allocate memory for extradata!\n");
libavformat/rtpdec_h264.c:        par->extradata_size = 0;
libavformat/rtpdec_h264.c:        av_freep(&par->extradata);
libavformat/rtpdec_h264.c:        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,
libavformat/rtpdec_h264.c:                                                 &par->extradata_size, value);
libavformat/rtpdec_h264.c:               par->extradata, par->extradata_size);
libavformat/adxdec.c:    if ((ret = ff_get_extradata(s, par, s->pb, c->header_size)) < 0)
libavformat/adxdec.c:    if (par->extradata_size < 12) {
libavformat/adxdec.c:        av_log(s, AV_LOG_ERROR, "Invalid extradata size.\n");
libavformat/adxdec.c:    par->channels    = AV_RB8 (par->extradata + 7);
libavformat/adxdec.c:    par->sample_rate = AV_RB32(par->extradata + 8);
libavformat/assenc.c:    if (par->extradata_size > 0) {
libavformat/assenc.c:        size_t header_size = par->extradata_size;
libavformat/assenc.c:        uint8_t *trailer = strstr(par->extradata, "\n[Events]");
libavformat/assenc.c:            header_size = (trailer - par->extradata);
libavformat/assenc.c:            ass->trailer_size = par->extradata_size - header_size;
libavformat/assenc.c:        avio_write(s->pb, par->extradata, header_size);
libavformat/assenc.c:        if (par->extradata[header_size - 1] != '\n')
libavformat/assenc.c:        ass->ssa_mode = !strstr(par->extradata, "\n[V4+ Styles]");
libavformat/assenc.c:        if (!strstr(par->extradata, "\n[Events]"))
libavformat/smush.c:        if ((ret = ff_alloc_extradata(vst->codecpar, 1024 + 2)) < 0)
libavformat/smush.c:        AV_WL16(vst->codecpar->extradata, subversion);
libavformat/smush.c:            AV_WL32(vst->codecpar->extradata + 2 + i * 4, palette[i]);
libavformat/mxfdec.c:    uint8_t *extradata;
libavformat/mxfdec.c:    int extradata_size;
libavformat/mxfdec.c:static const uint8_t mxf_sony_mpeg4_extradata[]            = { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0e,0x06,0x06,0x02,0x02,0x01,0x00,0x00 };
libavformat/mxfdec.c:        av_freep(&((MXFDescriptor *)*ctx)->extradata);
libavformat/mxfdec.c:        if (IS_KLV_KEY(uid, mxf_sony_mpeg4_extradata)) {
libavformat/mxfdec.c:            if (descriptor->extradata)
libavformat/mxfdec.c:                av_log(NULL, AV_LOG_WARNING, "Duplicate sony_mpeg4_extradata\n");
libavformat/mxfdec.c:            av_free(descriptor->extradata);
libavformat/mxfdec.c:            descriptor->extradata_size = 0;
libavformat/mxfdec.c:            descriptor->extradata = av_malloc(size);
libavformat/mxfdec.c:            if (!descriptor->extradata)
libavformat/mxfdec.c:            descriptor->extradata_size = size;
libavformat/mxfdec.c:            avio_read(pb, descriptor->extradata, size);
libavformat/mxfdec.c:        if (descriptor->extradata) {
libavformat/mxfdec.c:            if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) {
libavformat/mxfdec.c:                memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size);
libavformat/mxfdec.c:            ret = ff_generate_avci_extradata(st);
libavformat/omadec.c:        /* fake the ATRAC3 extradata
libavformat/omadec.c:        if ((ret = ff_alloc_extradata(st->codecpar, 14)) < 0)
libavformat/omadec.c:        edata = st->codecpar->extradata;
libavformat/oggenc.c:    if (par->extradata_size < FLAC_STREAMINFO_SIZE)
libavformat/oggenc.c:    bytestream_put_buffer(&p, par->extradata, FLAC_STREAMINFO_SIZE);
libavformat/oggenc.c:    if (par->extradata_size < SPEEX_HEADER_SIZE)
libavformat/oggenc.c:    bytestream_put_buffer(&p, par->extradata, SPEEX_HEADER_SIZE);
libavformat/oggenc.c:    if (par->extradata_size < OPUS_HEADER_SIZE)
libavformat/oggenc.c:    p = av_mallocz(par->extradata_size);
libavformat/oggenc.c:    oggstream->header_len[0] = par->extradata_size;
libavformat/oggenc.c:    bytestream_put_buffer(&p, par->extradata, par->extradata_size);
libavformat/oggenc.c:        if ((!st->codecpar->extradata || !st->codecpar->extradata_size) &&
libavformat/oggenc.c:            av_log(s, AV_LOG_ERROR, "No extradata present\n");
libavformat/oggenc.c:            if (avpriv_split_xiph_headers(st->codecpar->extradata, st->codecpar->extradata_size,
libavformat/wtvdec.c: * Parse MPEG1WAVEFORMATEX extradata structure
libavformat/wtvdec.c:    switch (AV_RL16(st->codecpar->extradata)) {
libavformat/wtvdec.c:    st->codecpar->bit_rate = AV_RL32(st->codecpar->extradata + 2); /* dwHeadBitrate */
libavformat/wtvdec.c:    switch (AV_RL16(st->codecpar->extradata + 6)) {
libavformat/wtvdec.c:        if (st->codecpar->extradata) {
libavformat/wtvdec.c:            av_freep(&st->codecpar->extradata);
libavformat/wtvdec.c:            st->codecpar->extradata_size = 0;
libavformat/wtvdec.c:            if (st->codecpar->extradata && st->codecpar->extradata_size >= 22)
libavformat/wtvdec.c:            /* ignore extradata; files produced by windows media center contain meaningless mpeg1 sequence header */
libavformat/codec2.c:    int mode = codec2_mode_from_extradata(st->codecpar->extradata);
libavformat/codec2.c:    ret = ff_alloc_extradata(st->codecpar, CODEC2_EXTRADATA_SIZE);
libavformat/codec2.c:    ret = ffio_read_size(s->pb, st->codecpar->extradata, CODEC2_EXTRADATA_SIZE);
libavformat/codec2.c:    version = AV_RB16(st->codecpar->extradata);
libavformat/codec2.c:    if (st->codecpar->extradata_size != CODEC2_EXTRADATA_SIZE) {
libavformat/codec2.c:        av_log(s, AV_LOG_ERROR, ".c2 files require exactly %i bytes of extradata (got %i)\n",
libavformat/codec2.c:               CODEC2_EXTRADATA_SIZE, st->codecpar->extradata_size);
libavformat/codec2.c:    avio_write(s->pb, st->codecpar->extradata, CODEC2_EXTRADATA_SIZE);
libavformat/codec2.c:    ret = ff_alloc_extradata(st->codecpar, CODEC2_EXTRADATA_SIZE);
libavformat/codec2.c:    codec2_make_extradata(st->codecpar->extradata, c2->mode);
libavformat/vc1test.c:    if ((ret = ff_get_extradata(s, st->codecpar, pb, VC1_EXTRADATA_SIZE)) < 0)
libavformat/cafdec.c:           description as extradata input. */
libavformat/cafdec.c:        if (skip < 0 || !st->codecpar->extradata ||
libavformat/cafdec.c:        if ((ret = ff_alloc_extradata(st->codecpar, ALAC_HEADER)) < 0)
libavformat/cafdec.c:                av_freep(&st->codecpar->extradata);
libavformat/cafdec.c:            if (avio_read(pb, st->codecpar->extradata, ALAC_HEADER) != ALAC_HEADER) {
libavformat/cafdec.c:                av_freep(&st->codecpar->extradata);
libavformat/cafdec.c:            AV_WB32(st->codecpar->extradata, 36);
libavformat/cafdec.c:            memcpy(&st->codecpar->extradata[4], "alac", 4);
libavformat/cafdec.c:            AV_WB32(&st->codecpar->extradata[8], 0);
libavformat/cafdec.c:            memcpy(&st->codecpar->extradata[12], preamble, 12);
libavformat/cafdec.c:            if (avio_read(pb, &st->codecpar->extradata[24], ALAC_NEW_KUKI - 12) != ALAC_NEW_KUKI - 12) {
libavformat/cafdec.c:                av_freep(&st->codecpar->extradata);
libavformat/cafdec.c:        // extradata at all. Multichannel streams are not supported.
libavformat/cafdec.c:    } else if ((ret = ff_get_extradata(s, st->codecpar, pb, size)) < 0) {
libavformat/rmdec.c:static int rm_read_extradata(AVFormatContext *s, AVIOContext *pb, AVCodecParameters *par, unsigned size)
libavformat/rmdec.c:        av_log(s, AV_LOG_ERROR, "extradata size %u too large\n", size);
libavformat/rmdec.c:    return ff_get_extradata(s, par, pb, size);
libavformat/rmdec.c:            st->codecpar->extradata_size= 0;
libavformat/rmdec.c:            av_freep(&st->codecpar->extradata);
libavformat/rmdec.c:            if ((ret = rm_read_extradata(s, pb, st->codecpar, codecdata_length)) < 0)
libavformat/rmdec.c:                if ((ret = rm_read_extradata(s, pb, st->codecpar, codecdata_length - 1)) < 0)
libavformat/rmdec.c:        if ((ret = rm_read_extradata(s, pb, st->codecpar, codec_data_size)) < 0)
libavformat/rmdec.c:        st->codecpar->codec_tag  = AV_RL32(st->codecpar->extradata);
libavformat/rmdec.c:        if ((ret = rm_read_extradata(s, pb, st->codecpar, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)
libavformat/anm.c:    ret = ff_get_extradata(s, st->codecpar, s->pb, 16*8 + 4*256);
libavformat/oggparseflac.c:        if ((ret = ff_alloc_extradata(st->codecpar, FLAC_STREAMINFO_SIZE)) < 0)
libavformat/oggparseflac.c:        memcpy(st->codecpar->extradata, streaminfo_start, st->codecpar->extradata_size);
libavformat/oggparseflac.c:        samplerate = AV_RB24(st->codecpar->extradata + 10) >> 4;
libavformat/tta.c:    if (ff_alloc_extradata(st->codecpar, avio_tell(s->pb) - start_offset))
libavformat/tta.c:    avio_read(s->pb, st->codecpar->extradata, st->codecpar->extradata_size);
libavformat/oggdec.c:    /* Chained files have extradata as a new packet */
libavformat/flvdec.c: * This demuxer will generate a 1 byte extradata for VP6F content.
libavformat/flvdec.c:    uint8_t *new_extradata[FLV_STREAM_TYPE_NB];
libavformat/flvdec.c:    int new_extradata_size[FLV_STREAM_TYPE_NB];
libavformat/flvdec.c:            if (par->extradata_size != 1) {
libavformat/flvdec.c:                ff_alloc_extradata(par, 1);
libavformat/flvdec.c:            if (par->extradata)
libavformat/flvdec.c:                par->extradata[0] = avio_r8(s->pb);
libavformat/flvdec.c:        av_freep(&flv->new_extradata[i]);
libavformat/flvdec.c:static int flv_get_extradata(AVFormatContext *s, AVStream *st, int size)
libavformat/flvdec.c:    if ((ret = ff_get_extradata(s, st->codecpar, s->pb, size)) < 0)
libavformat/flvdec.c:static int flv_queue_extradata(FLVContext *flv, AVIOContext *pb, int stream,
libavformat/flvdec.c:    av_free(flv->new_extradata[stream]);
libavformat/flvdec.c:    flv->new_extradata[stream] = av_mallocz(size +
libavformat/flvdec.c:    if (!flv->new_extradata[stream])
libavformat/flvdec.c:    flv->new_extradata_size[stream] = size;
libavformat/flvdec.c:    avio_read(pb, flv->new_extradata[stream], size);
libavformat/flvdec.c:        if (type == 0 && (!st->codecpar->extradata || st->codecpar->codec_id == AV_CODEC_ID_AAC ||
libavformat/flvdec.c:            if (st->codecpar->extradata) {
libavformat/flvdec.c:                if ((ret = flv_queue_extradata(flv, s->pb, stream_type, size)) < 0)
libavformat/flvdec.c:            if ((ret = flv_get_extradata(s, st, size)) < 0)
libavformat/flvdec.c:                st->codecpar->extradata_size = 2;
libavformat/flvdec.c:    if (flv->new_extradata[stream_type]) {
libavformat/flvdec.c:                                          flv->new_extradata[stream_type],
libavformat/flvdec.c:                                          flv->new_extradata_size[stream_type]);
libavformat/flvdec.c:            flv->new_extradata[stream_type]      = NULL;
libavformat/flvdec.c:            flv->new_extradata_size[stream_type] = 0;
libavformat/mpegts.c:                st->codecpar->extradata_size > 0)
libavformat/mpegts.c:                st->codecpar->extradata_size > 0)
libavformat/mpegts.c:                    st->codecpar->extradata_size > 0) {
libavformat/mpegts.c:                st->codecpar->extradata_size > 0) {
libavformat/mpegts.c:            uint8_t *extradata = NULL;
libavformat/mpegts.c:                if (st->codecpar->extradata == NULL) {
libavformat/mpegts.c:                    ret = ff_alloc_extradata(st->codecpar, language_count * 2);
libavformat/mpegts.c:                if (st->codecpar->extradata_size < language_count * 2)
libavformat/mpegts.c:                extradata = st->codecpar->extradata;
libavformat/mpegts.c:                    memcpy(extradata, *pp, 2);
libavformat/mpegts.c:                    extradata += 2;
libavformat/mpegts.c:                uint8_t *extradata;
libavformat/mpegts.c:                if (st->codecpar->extradata == NULL) {
libavformat/mpegts.c:                    ret = ff_alloc_extradata(st->codecpar, language_count * 5);
libavformat/mpegts.c:                if (st->codecpar->extradata_size < language_count * 5)
libavformat/mpegts.c:                extradata = st->codecpar->extradata;
libavformat/mpegts.c:                    extradata[4] = get8(pp, desc_end); /* subtitling_type */
libavformat/mpegts.c:                    memcpy(extradata, *pp, 4); /* composition_page_id and ancillary_page_id */
libavformat/mpegts.c:                    extradata += 5;
libavformat/mpegts.c:            if (!st->codecpar->extradata) {
libavformat/mpegts.c:                st->codecpar->extradata = av_mallocz(sizeof(opus_default_extradata) +
libavformat/mpegts.c:                if (!st->codecpar->extradata)
libavformat/mpegts.c:                st->codecpar->extradata_size = sizeof(opus_default_extradata);
libavformat/mpegts.c:                memcpy(st->codecpar->extradata, opus_default_extradata, sizeof(opus_default_extradata));
libavformat/mpegts.c:                    st->codecpar->extradata[9]  = channels = channel_config_code ? channel_config_code : 2;
libavformat/mpegts.c:                    st->codecpar->extradata[18] = channel_config_code ? (channels > 2) : /* Dual Mono */ 255;
libavformat/mpegts.c:                    st->codecpar->extradata[19] = opus_stream_cnt[channel_config_code];
libavformat/mpegts.c:                    st->codecpar->extradata[20] = opus_coupled_stream_cnt[channel_config_code];
libavformat/mpegts.c:                    memcpy(&st->codecpar->extradata[21], opus_channel_map[channels - 1], channels);
libavformat/aaxdec.c:    int ret, extradata_size;
libavformat/aaxdec.c:        extradata_size = avio_rb16(pb) + 4;
libavformat/aaxdec.c:        if (extradata_size < 12) {
libavformat/aaxdec.c:        ret = ff_get_extradata(s, par, pb, extradata_size);
libavformat/aaxdec.c:        par->channels    = AV_RB8 (par->extradata + 7);
libavformat/aaxdec.c:        par->sample_rate = AV_RB32(par->extradata + 8);
libavformat/aaxdec.c:    int ret, extradata_size = 0;
libavformat/aaxdec.c:    uint8_t *extradata = NULL;
libavformat/aaxdec.c:            extradata_size = avio_rb16(pb) + 4;
libavformat/aaxdec.c:            if (extradata_size < 12)
libavformat/aaxdec.c:            extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/aaxdec.c:            if (!extradata)
libavformat/aaxdec.c:            if (avio_read(pb, extradata, extradata_size) != extradata_size) {
libavformat/aaxdec.c:                av_free(extradata);
libavformat/aaxdec.c:            memset(extradata + extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/aaxdec.c:        av_free(extradata);
libavformat/aaxdec.c:    if (extradata) {
libavformat/aaxdec.c:        ret = av_packet_add_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, extradata, extradata_size);
libavformat/aaxdec.c:            av_free(extradata);
libavformat/asfdec_o.c:        st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;
libavformat/asfdec_o.c:        if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +
libavformat/asfdec_o.c:            st->codecpar->extradata_size = 0;
libavformat/asfdec_o.c:        memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,
libavformat/asfdec_o.c:        if ((ret = avio_read(pb, st->codecpar->extradata,
libavformat/asfdec_o.c:                             st->codecpar->extradata_size)) < 0)
libavformat/hnm.c:    if ((ret = ff_alloc_extradata(vst->codecpar, 1)) < 0)
libavformat/hnm.c:    vst->codecpar->extradata[0] = width == 640 ? 0x4a : 0x40;
libavformat/hlsenc.c:        uint8_t *data = st->codecpar->extradata;
libavformat/hlsenc.c:        uint8_t *data = st->codecpar->extradata;
libavformat/hlsenc.c:        /* check the boundary of data which from current position is small than extradata_size */
libavformat/hlsenc.c:        while (data && (data - st->codecpar->extradata + 19) < st->codecpar->extradata_size) {
libavformat/hlsenc.c:                remain_size = st->codecpar->extradata_size - (data - st->codecpar->extradata);
libavformat/ttmlenc.c:        // by the existence of the lavc ttmlenc extradata.
libavformat/ttmlenc.c:        ttml_ctx->input_type = (st->codecpar->extradata &&
libavformat/ttmlenc.c:                                st->codecpar->extradata_size >= TTMLENC_EXTRADATA_SIGNATURE_SIZE &&
libavformat/ttmlenc.c:                                !memcmp(st->codecpar->extradata,
libavformat/adtsenc.c:static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)
libavformat/adtsenc.c:    if (par->extradata_size > 0)
libavformat/adtsenc.c:        return adts_decode_extradata(s, adts, par->extradata,
libavformat/adtsenc.c:                                     par->extradata_size);
libavformat/adtsenc.c:    if (!par->extradata_size) {
libavformat/adtsenc.c:            ret = adts_decode_extradata(s, adts, side_data, side_data_size);
libavformat/adtsenc.c:            ret = ff_alloc_extradata(par, side_data_size);
libavformat/adtsenc.c:            memcpy(par->extradata, side_data, side_data_size);
libavformat/apc.c:    if ((ret = ff_get_extradata(s, st->codecpar, pb, 2 * 4)) < 0)
libavformat/westwood_vqa.c:    if ((ret = ff_get_extradata(s, st->codecpar, pb, VQA_HEADER_SIZE)) < 0)
libavformat/westwood_vqa.c:    header = st->codecpar->extradata;
libavformat/westwood_vqa.c:                        if ((ret = ff_alloc_extradata(st->codecpar, 2)) < 0)
libavformat/westwood_vqa.c:                        AV_WL16(st->codecpar->extradata, wsvqa->version);
libavformat/hashenc.c:static void framehash_print_extradata(struct AVFormatContext *s)
libavformat/hashenc.c:        if (par->extradata) {
libavformat/hashenc.c:            avio_printf(s->pb, "#extradata %d, %31d, ", i, par->extradata_size);
libavformat/hashenc.c:            av_hash_update(c->hashes[0], par->extradata, par->extradata_size);
libavformat/hashenc.c:    framehash_print_extradata(s);
libavformat/rtpenc_aac.c:    if ((s1->streams[0]->codecpar->extradata_size) == 0) {
libavformat/apngdec.c:static int append_extradata(AVCodecParameters *par, AVIOContext *pb, int len)
libavformat/apngdec.c:    int previous_size = par->extradata_size;
libavformat/apngdec.c:    uint8_t *new_extradata;
libavformat/apngdec.c:    new_extradata = av_realloc(par->extradata, new_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/apngdec.c:    if (!new_extradata)
libavformat/apngdec.c:    memset(new_extradata + new_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/apngdec.c:    par->extradata = new_extradata;
libavformat/apngdec.c:    par->extradata_size = new_size;
libavformat/apngdec.c:    if ((ret = ffio_read_size(pb, par->extradata + previous_size, len)) < 0)
libavformat/apngdec.c:    /* extradata will contain every chunk up to the first fcTL (excluded) */
libavformat/apngdec.c:    ret = ff_alloc_extradata(st->codecpar, len + 12);
libavformat/apngdec.c:    AV_WB32(st->codecpar->extradata,    len);
libavformat/apngdec.c:    AV_WL32(st->codecpar->extradata+4,  tag);
libavformat/apngdec.c:    AV_WB32(st->codecpar->extradata+8,  st->codecpar->width);
libavformat/apngdec.c:    AV_WB32(st->codecpar->extradata+12, st->codecpar->height);
libavformat/apngdec.c:    if ((ret = ffio_read_size(pb, st->codecpar->extradata + 16, 9)) < 0)
libavformat/apngdec.c:                (ret = append_extradata(st->codecpar, pb, len + 12)) < 0)
libavformat/apngdec.c:            ctx->num_frames = AV_RB32(st->codecpar->extradata + ret + 8);
libavformat/apngdec.c:            ctx->num_play   = AV_RB32(st->codecpar->extradata + ret + 12);
libavformat/apngdec.c:                (ret = append_extradata(st->codecpar, pb, len + 12)) < 0)
libavformat/apngdec.c:        if ((ret = avio_seek(pb, s->streams[0]->codecpar->extradata_size + 8, SEEK_SET)) < 0)
libavformat/sdp.c:static char *extradata2psets(AVFormatContext *s, AVCodecParameters *par)
libavformat/sdp.c:    uint8_t *extradata = par->extradata;
libavformat/sdp.c:    int extradata_size = par->extradata_size;
libavformat/sdp.c:    if (par->extradata_size > MAX_EXTRADATA_SIZE) {
libavformat/sdp.c:        av_log(s, AV_LOG_ERROR, "Too much extradata!\n");
libavformat/sdp.c:    if (par->extradata[0] == 1) {
libavformat/sdp.c:        if (ff_avc_write_annexb_extradata(par->extradata, &extradata,
libavformat/sdp.c:                                          &extradata_size))
libavformat/sdp.c:        tmpbuf = extradata;
libavformat/sdp.c:    r = ff_avc_find_startcode(extradata, extradata + extradata_size);
libavformat/sdp.c:    while (r < extradata + extradata_size) {
libavformat/sdp.c:        r1 = ff_avc_find_startcode(r, extradata + extradata_size);
libavformat/sdp.c:static char *extradata2psets_hevc(AVCodecParameters *par)
libavformat/sdp.c:    uint8_t *extradata = par->extradata;
libavformat/sdp.c:    int extradata_size = par->extradata_size;
libavformat/sdp.c:    if (par->extradata[0] != 1) {
libavformat/sdp.c:        if (ff_isom_write_hvcc(pb, par->extradata, par->extradata_size, 0) < 0) {
libavformat/sdp.c:        extradata_size = avio_close_dyn_buf(pb, &extradata);
libavformat/sdp.c:        tmpbuf = extradata;
libavformat/sdp.c:    if (extradata_size < 23)
libavformat/sdp.c:    num_arrays = extradata[22];
libavformat/sdp.c:        if (pos + 3 > extradata_size)
libavformat/sdp.c:        nalu_type = extradata[pos] & 0x3f;
libavformat/sdp.c:        num_nalus = AV_RB16(&extradata[pos + 1]);
libavformat/sdp.c:            if (pos + 2 > extradata_size)
libavformat/sdp.c:            len = AV_RB16(&extradata[pos]);
libavformat/sdp.c:            if (pos + len > extradata_size)
libavformat/sdp.c:        num_nalus = AV_RB16(&extradata[pos + 1]);
libavformat/sdp.c:            int len = AV_RB16(&extradata[pos]);
libavformat/sdp.c:                                  &extradata[pos], len)) {
libavformat/sdp.c:static char *extradata2config(AVFormatContext *s, AVCodecParameters *par)
libavformat/sdp.c:    if (par->extradata_size > MAX_EXTRADATA_SIZE) {
libavformat/sdp.c:        av_log(s, AV_LOG_ERROR, "Too much extradata!\n");
libavformat/sdp.c:    config = av_malloc(10 + par->extradata_size * 2);
libavformat/sdp.c:    ff_data_to_hex(config + 9, par->extradata, par->extradata_size, 0);
libavformat/sdp.c:    config[9 + par->extradata_size * 2] = 0;
libavformat/sdp.c:static char *xiph_extradata2config(AVFormatContext *s, AVCodecParameters *par)
libavformat/sdp.c:    if (avpriv_split_xiph_headers(par->extradata, par->extradata_size,
libavformat/sdp.c:            if (p->extradata_size) {
libavformat/sdp.c:                config = extradata2psets(fmt, p);
libavformat/sdp.c:            if (p->extradata_size)
libavformat/sdp.c:                config = extradata2psets_hevc(p);
libavformat/sdp.c:            if (p->extradata_size) {
libavformat/sdp.c:                config = extradata2config(fmt, p);
libavformat/sdp.c:                if (p->extradata_size) {
libavformat/sdp.c:                    config = extradata2config(fmt, p);
libavformat/sdp.c:            if (p->extradata_size)
libavformat/sdp.c:                config = xiph_extradata2config(fmt, p);
libavformat/sdp.c:            if (p->extradata_size)
libavformat/sdp.c:                config = xiph_extradata2config(fmt, p);
libavformat/samidec.c:    res = ff_bprint_to_codecpar_extradata(st->codecpar, &hdr_buf);
libavformat/mtv.c:    st->codecpar->extradata       = av_strdup("BottomUp");
libavformat/mtv.c:    if (!st->codecpar->extradata)
libavformat/mtv.c:    st->codecpar->extradata_size  = 9;
libavformat/acedec.c:    ret = ff_alloc_extradata(par, 14);
libavformat/acedec.c:    AV_WL16(st->codecpar->extradata, 1);
libavformat/acedec.c:    AV_WL16(st->codecpar->extradata+2, 2048 * par->channels);
libavformat/acedec.c:    AV_WL16(st->codecpar->extradata+4, 0);
libavformat/acedec.c:    AV_WL16(st->codecpar->extradata+6, codec == 4 ? 1 : 0);
libavformat/acedec.c:    AV_WL16(st->codecpar->extradata+8, codec == 4 ? 1 : 0);
libavformat/acedec.c:    AV_WL16(st->codecpar->extradata+10, 1);
libavformat/acedec.c:    AV_WL16(st->codecpar->extradata+12, 0);
libavformat/sbgdec.c:    if ((ret = ff_alloc_extradata(par, edata_size)) < 0)
libavformat/sbgdec.c:    edata = par->extradata;
libavformat/sbgdec.c:    if (edata != par->extradata + edata_size)
libavformat/redspark.c:    if (ff_alloc_extradata(par, 32 * par->channels)) {
libavformat/redspark.c:        if (bytestream2_get_bufferu(&gbc, par->extradata + i * 32, 32) != 32) {
libavformat/nuv.c:                if ((ret = ff_get_extradata(NULL, vst->codecpar, pb, size)) < 0)
libavformat/asfenc.c:            wav_extra_size = par->extradata_size;
libavformat/asfenc.c:            avio_wl16(pb, 40 + par->extradata_size); /* size */
libavformat/webmdashenc.c:            gold_par->extradata_size != par->extradata_size ||
libavformat/webmdashenc.c:            (par->extradata_size > 0 &&
libavformat/webmdashenc.c:             memcmp(gold_par->extradata, par->extradata, par->extradata_size))) {
libavformat/avc.h:int ff_avc_write_annexb_extradata(const uint8_t *in, uint8_t **buf, int *size);
libavformat/iff.c: * no extradata changing in this frame.
libavformat/iff.c:            res = ff_alloc_extradata(st->codecpar,
libavformat/iff.c:            if (avio_read(pb, st->codecpar->extradata + IFF_EXTRA_VIDEO_SIZE, data_size) < 0) {
libavformat/iff.c:                av_freep(&st->codecpar->extradata);
libavformat/iff.c:                st->codecpar->extradata_size = 0;
libavformat/iff.c:        if (!st->codecpar->extradata) {
libavformat/iff.c:            int ret = ff_alloc_extradata(st->codecpar, IFF_EXTRA_VIDEO_SIZE);
libavformat/iff.c:        av_assert0(st->codecpar->extradata_size >= IFF_EXTRA_VIDEO_SIZE);
libavformat/iff.c:        buf = st->codecpar->extradata;
libavformat/a64.c:    if (par->extradata_size < 4) {
libavformat/a64.c:        av_log(s, AV_LOG_ERROR, "Missing extradata\n");
libavformat/a64.c:        header[3] = AV_RB32(par->extradata+0);
libavformat/a64.c:        header[3] = AV_RB32(par->extradata+0);
libavformat/mvi.c:    if ((ret = ff_alloc_extradata(vst->codecpar, 2)) < 0)
libavformat/mvi.c:    vst->codecpar->extradata[0] = avio_r8(pb);
libavformat/mvi.c:    vst->codecpar->extradata[1] = avio_r8(pb);
libavformat/smoothstreamingenc.c:    uint8_t *ptr = par->extradata;
libavformat/smoothstreamingenc.c:    int size = par->extradata_size;
libavformat/smoothstreamingenc.c:        ff_avc_write_annexb_extradata(ptr, &ptr, &size);
libavformat/smoothstreamingenc.c:            ptr = par->extradata;
libavformat/smoothstreamingenc.c:    if (ptr != par->extradata)
libavformat/dump.c:            av_log(ctx, AV_LOG_INFO, "new extradata");
libavformat/microdvddec.c:            if (!st->codecpar->extradata && sscanf(line, "{DEFAULT}{}%c", &c) == 1) {
libavformat/microdvddec.c:                ret = ff_alloc_extradata(st->codecpar, size);
libavformat/microdvddec.c:                memcpy(st->codecpar->extradata, line + 11, size);
libavformat/tests/movenc.c:static const uint8_t h264_extradata[] = {
libavformat/tests/movenc.c:static const uint8_t aac_extradata[] = {
libavformat/tests/movenc.c:    st->codecpar->extradata_size = sizeof(h264_extradata);
libavformat/tests/movenc.c:    st->codecpar->extradata = av_mallocz(st->codecpar->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/tests/movenc.c:    if (!st->codecpar->extradata)
libavformat/tests/movenc.c:    memcpy(st->codecpar->extradata, h264_extradata, sizeof(h264_extradata));
libavformat/tests/movenc.c:    st->codecpar->extradata_size = sizeof(aac_extradata);
libavformat/tests/movenc.c:    st->codecpar->extradata = av_mallocz(st->codecpar->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/tests/movenc.c:    if (!st->codecpar->extradata)
libavformat/tests/movenc.c:    memcpy(st->codecpar->extradata, aac_extradata, sizeof(aac_extradata));
libavformat/fsb.c:            ret = ff_alloc_extradata(par, 32 * par->channels);
libavformat/fsb.c:                avio_read(pb, par->extradata + 32 * c, 32);
libavformat/fsb.c:            ret = ff_alloc_extradata(par, 34);
libavformat/fsb.c:            memset(par->extradata, 0, 34);
libavformat/fsb.c:            ret = ff_alloc_extradata(par, 32 * par->channels);
libavformat/fsb.c:                avio_read(pb, par->extradata + 32 * c, 32);
libavformat/mov.c:static int mov_realloc_extradata(AVCodecParameters *par, MOVAtom atom)
libavformat/mov.c:    uint64_t size = (uint64_t)par->extradata_size + atom.size + 8 + AV_INPUT_BUFFER_PADDING_SIZE;
libavformat/mov.c:    if ((err = av_reallocp(&par->extradata, size)) < 0) {
libavformat/mov.c:        par->extradata_size = 0;
libavformat/mov.c:    par->extradata_size = size - AV_INPUT_BUFFER_PADDING_SIZE;
libavformat/mov.c:/* Read a whole atom into the extradata return the size of the atom read, possibly truncated if != atom.size */
libavformat/mov.c:static int64_t mov_read_atom_into_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,
libavformat/mov.c:        par->extradata_size -= atom.size;
libavformat/mov.c:        av_log(c->fc, AV_LOG_WARNING, "truncated extradata\n");
libavformat/mov.c:        par->extradata_size -= atom.size - err;
libavformat/mov.c:/* FIXME modify QDM2/SVQ3/H.264 decoders to take full atom as extradata */
libavformat/mov.c:static int mov_read_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,
libavformat/mov.c:        return 0; /* unexpected codec_id - don't mess with extradata */
libavformat/mov.c:    original_size = st->codecpar->extradata_size;
libavformat/mov.c:    err = mov_realloc_extradata(st->codecpar, atom);
libavformat/mov.c:    err =  mov_read_atom_into_extradata(c, pb, atom, st->codecpar,  st->codecpar->extradata + original_size);
libavformat/mov.c:/* wrapper functions for reading ALAC/AVS/MJPEG/MJPEG2000 extradata atoms only for those codecs */
libavformat/mov.c:    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_ALAC);
libavformat/mov.c:    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_AVS);
libavformat/mov.c:    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_JPEG2000);
libavformat/mov.c:    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_R10K);
libavformat/mov.c:    int ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_AVUI);
libavformat/mov.c:        ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_DNXHD);
libavformat/mov.c:    int ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_TARGA_Y216);
libavformat/mov.c:        if (par->extradata_size >= 40) {
libavformat/mov.c:            par->height = AV_RB16(&par->extradata[36]);
libavformat/mov.c:            par->width  = AV_RB16(&par->extradata[38]);
libavformat/mov.c:            original_size = par->extradata_size;
libavformat/mov.c:            ret = mov_realloc_extradata(par, atom);
libavformat/mov.c:                length =  mov_read_atom_into_extradata(c, pb, atom, par, par->extradata + original_size);
libavformat/mov.c:                    const uint8_t range_value = par->extradata[original_size + 19];
libavformat/mov.c:                  /* For some reason the whole atom was not added to the extradata */
libavformat/mov.c:                av_log(c->fc, AV_LOG_ERROR, "aclr not decoded - unable to add atom to extradata\n");
libavformat/mov.c:    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_SVQ3);
libavformat/mov.c:        ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size);
libavformat/mov.c:            } else if (!st->codecpar->extradata_size) {
libavformat/mov.c:                st->codecpar->extradata = av_mallocz(ALAC_EXTRADATA_SIZE + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/mov.c:                if (!st->codecpar->extradata)
libavformat/mov.c:                st->codecpar->extradata_size = ALAC_EXTRADATA_SIZE;
libavformat/mov.c:                AV_WB32(st->codecpar->extradata    , ALAC_EXTRADATA_SIZE);
libavformat/mov.c:                AV_WB32(st->codecpar->extradata + 4, MKTAG('a','l','a','c'));
libavformat/mov.c:                AV_WB64(st->codecpar->extradata + 12, buffer);
libavformat/mov.c:                avio_read(pb, st->codecpar->extradata + 20, 16);
libavformat/mov.c: * This function reads atom content and puts data in extradata without tag
libavformat/mov.c: * nor size unlike mov_read_extradata.
libavformat/mov.c:    if (st->codecpar->extradata_size > 1 && st->codecpar->extradata) {
libavformat/mov.c:    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size);
libavformat/mov.c:           the hvcC extradata box available as specified,
libavformat/mov.c:    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size - 7);
libavformat/mov.c: * but can have extradata appended at the end after the 40 bytes belonging
libavformat/mov.c:    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size - 40);
libavformat/mov.c:static int mov_rewrite_dvd_sub_extradata(AVStream *st)
libavformat/mov.c:    uint8_t *src = st->codecpar->extradata;
libavformat/mov.c:    if (st->codecpar->extradata_size != 64)
libavformat/mov.c:    ret = ff_alloc_extradata(st->codecpar, strlen(buf));
libavformat/mov.c:    memcpy(st->codecpar->extradata, buf, st->codecpar->extradata_size);
libavformat/mov.c:        ret = ff_get_extradata(c->fc, st->codecpar, pb, size);
libavformat/mov.c:            val = AV_RB32(st->codecpar->extradata + 4);
libavformat/mov.c:            st->avg_frame_rate.num = AV_RB32(st->codecpar->extradata + 8); /* timescale */
libavformat/mov.c:            st->avg_frame_rate.den = AV_RB32(st->codecpar->extradata + 12); /* frameDuration */
libavformat/mov.c:                uint32_t len = AV_RB32(st->codecpar->extradata + 18); /* name atom length */
libavformat/mov.c:                uint32_t format = AV_RB32(st->codecpar->extradata + 22);
libavformat/mov.c:                    uint16_t str_size = AV_RB16(st->codecpar->extradata + 26); /* string length */
libavformat/mov.c:                        st->codecpar->extradata[30] /* Don't add empty string */) {
libavformat/mov.c:                        memcpy(reel_name, st->codecpar->extradata + 30, str_size);
libavformat/mov.c:        if (st->codecpar->extradata_size == 36) {
libavformat/mov.c:            st->codecpar->channels    = AV_RB8 (st->codecpar->extradata + 21);
libavformat/mov.c:            st->codecpar->sample_rate = AV_RB32(st->codecpar->extradata + 32);
libavformat/mov.c:        if (sc->extradata && st->codecpar->extradata) {
libavformat/mov.c:            int extra_size = st->codecpar->extradata_size;
libavformat/mov.c:            /* Move the current stream extradata to the stream context one. */
libavformat/mov.c:            sc->extradata_size[pseudo_stream_id] = extra_size;
libavformat/mov.c:            sc->extradata[pseudo_stream_id] = st->codecpar->extradata;
libavformat/mov.c:            st->codecpar->extradata      = NULL;
libavformat/mov.c:            st->codecpar->extradata_size = 0;
libavformat/mov.c:    if (sc->extradata) {
libavformat/mov.c:    /* Prepare space for hosting multiple extradata. */
libavformat/mov.c:    sc->extradata = av_mallocz_array(entries, sizeof(*sc->extradata));
libavformat/mov.c:    if (!sc->extradata)
libavformat/mov.c:    sc->extradata_size = av_mallocz_array(entries, sizeof(*sc->extradata_size));
libavformat/mov.c:    if (!sc->extradata_size) {
libavformat/mov.c:    /* Restore back the primary extradata. */
libavformat/mov.c:    av_freep(&st->codecpar->extradata);
libavformat/mov.c:    st->codecpar->extradata_size = sc->extradata_size[0];
libavformat/mov.c:    if (sc->extradata_size[0]) {
libavformat/mov.c:        st->codecpar->extradata = av_mallocz(sc->extradata_size[0] + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/mov.c:        if (!st->codecpar->extradata)
libavformat/mov.c:        memcpy(st->codecpar->extradata, sc->extradata[0], sc->extradata_size[0]);
libavformat/mov.c:    if (sc->extradata) {
libavformat/mov.c:            av_freep(&sc->extradata[j]);
libavformat/mov.c:    av_freep(&sc->extradata);
libavformat/mov.c:    av_freep(&sc->extradata_size);
libavformat/mov.c:    if (!st->codecpar->extradata_size && st->codecpar->codec_id == AV_CODEC_ID_H264 &&
libavformat/mov.c:        ret = ff_generate_avci_extradata(st);
libavformat/mov.c:       updated to handle isobmff style extradata this can be removed. */
libavformat/mov.c:    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size - 4);
libavformat/mov.c:    ret = ff_get_extradata(c->fc, st->codecpar, pb, size);
libavformat/mov.c:    if ((ret = ff_alloc_extradata(st->codecpar, size)) < 0)
libavformat/mov.c:    AV_WL32(st->codecpar->extradata, MKTAG('O','p','u','s'));
libavformat/mov.c:    AV_WL32(st->codecpar->extradata + 4, MKTAG('H','e','a','d'));
libavformat/mov.c:    AV_WB8(st->codecpar->extradata + 8, 1); /* OpusHead version */
libavformat/mov.c:    avio_read(pb, st->codecpar->extradata + 9, size - 9);
libavformat/mov.c:    pre_skip = AV_RB16(st->codecpar->extradata + 10);
libavformat/mov.c:    AV_WL16(st->codecpar->extradata + 10, pre_skip);
libavformat/mov.c:    AV_WL32(st->codecpar->extradata + 12, AV_RB32(st->codecpar->extradata + 12));
libavformat/mov.c:    AV_WL16(st->codecpar->extradata + 16, AV_RB16(st->codecpar->extradata + 16));
libavformat/mov.c:        if (sc->extradata)
libavformat/mov.c:                av_free(sc->extradata[j]);
libavformat/mov.c:        av_freep(&sc->extradata);
libavformat/mov.c:        av_freep(&sc->extradata_size);
libavformat/mov.c:                if ((err = mov_rewrite_dvd_sub_extradata(st)) < 0)
libavformat/mov.c:static int mov_change_extradata(MOVStreamContext *sc, AVPacket *pkt)
libavformat/mov.c:    uint8_t *side, *extradata;
libavformat/mov.c:    int extradata_size;
libavformat/mov.c:    /* Notify the decoder that extradata changed. */
libavformat/mov.c:    extradata_size = sc->extradata_size[sc->last_stsd_index];
libavformat/mov.c:    extradata = sc->extradata[sc->last_stsd_index];
libavformat/mov.c:    if (extradata_size > 0 && extradata) {
libavformat/mov.c:                                       extradata_size);
libavformat/mov.c:        memcpy(side, extradata, extradata_size);
libavformat/mov.c:            ret = mov_change_extradata(sc, pkt);
libavformat/avidec.c:    uint8_t *data = st->codecpar->extradata;
libavformat/avidec.c:    int data_size = st->codecpar->extradata_size;
libavformat/avidec.c:                            st->codecpar->extradata_size = esize - 10 * 4;
libavformat/avidec.c:                            st->codecpar->extradata_size =  size - 10 * 4;
libavformat/avidec.c:                        if (st->codecpar->extradata) {
libavformat/avidec.c:                            av_log(s, AV_LOG_WARNING, "New extradata in strf chunk, freeing previous one.\n");
libavformat/avidec.c:                        ret = ff_get_extradata(s, st->codecpar, pb,
libavformat/avidec.c:                                               st->codecpar->extradata_size);
libavformat/avidec.c:                    if (st->codecpar->extradata_size & 1)
libavformat/avidec.c:                    /* Extract palette from extradata if bpp <= 8.
libavformat/avidec.c:                     * This code assumes that extradata contains only palette.
libavformat/avidec.c:                    if (st->codecpar->extradata_size &&
libavformat/avidec.c:                        pal_size = FFMIN(pal_size, st->codecpar->extradata_size);
libavformat/avidec.c:                        pal_src  = st->codecpar->extradata +
libavformat/avidec.c:                                   st->codecpar->extradata_size - pal_size;
libavformat/avidec.c:                        if (pal_src - st->codecpar->extradata >= 9 &&
libavformat/avidec.c:                            !memcmp(st->codecpar->extradata + st->codecpar->extradata_size - 9, "BottomUp", 9))
libavformat/avidec.c:                        (st->codecpar->extradata_size < 31 ||
libavformat/avidec.c:                          memcmp(&st->codecpar->extradata[28], "1:1", 3)))
libavformat/avidec.c:                        st->codecpar->extradata_size < 1U << 30) {
libavformat/avidec.c:                        st->codecpar->extradata_size += 9;
libavformat/avidec.c:                        if ((ret = av_reallocp(&st->codecpar->extradata,
libavformat/avidec.c:                                               st->codecpar->extradata_size +
libavformat/avidec.c:                            st->codecpar->extradata_size = 0;
libavformat/avidec.c:                            memcpy(st->codecpar->extradata + st->codecpar->extradata_size - 9,
libavformat/avidec.c:                    /* ADTS header is in extradata, AAC without header must be
libavformat/avidec.c:                        st->codecpar->extradata_size)
libavformat/avidec.c:                || s->streams[stream_index]->codecpar->extradata_size
libavformat/avidec.c:                    if (st->codecpar->extradata) {
libavformat/avidec.c:                        av_log(s, AV_LOG_WARNING, "New extradata in strd chunk, freeing previous one.\n");
libavformat/avidec.c:                    if ((ret = ff_get_extradata(s, st->codecpar, pb, size)) < 0)
libavformat/avidec.c:                if (st->codecpar->extradata_size & 1) //FIXME check if the encoder really did this correctly
libavformat/asfdec_f.c:            st->codecpar->extradata_size = ffio_limit(pb, sizeX - 40);
libavformat/asfdec_f.c:            st->codecpar->extradata      = av_mallocz(st->codecpar->extradata_size +
libavformat/asfdec_f.c:            if (!st->codecpar->extradata)
libavformat/asfdec_f.c:            avio_read(pb, st->codecpar->extradata, st->codecpar->extradata_size);
libavformat/asfdec_f.c:        /* Extract palette from extradata if bpp <= 8 */
libavformat/asfdec_f.c:        /* This code assumes that extradata contains only palette */
libavformat/asfdec_f.c:        if (st->codecpar->extradata_size && (st->codecpar->bits_per_coded_sample <= 8)) {
libavformat/asfdec_f.c:            for (i = 0; i < FFMIN(st->codecpar->extradata_size, AVPALETTE_SIZE) / 4; i++)
libavformat/asfdec_f.c:                asf_st->palette[i] = av_bswap32(((uint32_t *)st->codecpar->extradata)[i]);
libavformat/asfdec_f.c:            memcpy(asf_st->palette, st->codecpar->extradata,
libavformat/asfdec_f.c:                   FFMIN(st->codecpar->extradata_size, AVPALETTE_SIZE));
libavformat/asfdec_f.c:             * with wrong w/h in extradata while a correct one is in the stream.
libavformat/asfdec_f.c:            av_freep(&st->codecpar->extradata);
libavformat/asfdec_f.c:            st->codecpar->extradata_size = 0;
libavformat/rtpdec_latm.c:    ret = ff_alloc_extradata(st->codecpar, (get_bits_left(&gb) + 7)/8);
libavformat/rtpdec_latm.c:    for (i = 0; i < st->codecpar->extradata_size; i++)
libavformat/rtpdec_latm.c:        st->codecpar->extradata[i] = get_bits(&gb, 8);
libavformat/vividas.c:            ret = ff_alloc_extradata(st->codecpar, xd_size);
libavformat/vividas.c:            p = st->codecpar->extradata;
libavformat/vividas.c:                    st->codecpar->extradata_size = 0;
libavformat/vividas.c:                    av_freep(&st->codecpar->extradata);
libavformat/vividas.c:            if (offset < st->codecpar->extradata_size)
libavformat/vividas.c:                st->codecpar->extradata_size = offset;
libavformat/mvdec.c:            if (!st->codecpar->extradata) {
libavformat/mvdec.c:                st->codecpar->extradata = av_strdup("BottomUp");
libavformat/mvdec.c:                if (!st->codecpar->extradata)
libavformat/mvdec.c:                st->codecpar->extradata_size = 9;
libavformat/wvdec.c:    if ((ret = ff_alloc_extradata(st->codecpar, 2)) < 0)
libavformat/wvdec.c:    AV_WL16(st->codecpar->extradata, wc->header.version);
libavformat/oggparsetheora.c:    int cds               = st->codecpar->extradata_size + os->psize + 2;
libavformat/oggparsetheora.c:    if ((err = av_reallocp(&st->codecpar->extradata,
libavformat/oggparsetheora.c:        st->codecpar->extradata_size = 0;
libavformat/oggparsetheora.c:    memset(st->codecpar->extradata + cds, 0, AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/oggparsetheora.c:    cdp    = st->codecpar->extradata + st->codecpar->extradata_size;
libavformat/oggparsetheora.c:    st->codecpar->extradata_size = cds;
libavformat/afc.c:    if ((ret = ff_alloc_extradata(st->codecpar, 1)) < 0)
libavformat/afc.c:    st->codecpar->extradata[0] = 8 * st->codecpar->channels;
libavformat/aixdec.c:        ff_get_extradata(s, s->streams[i]->codecpar, s->pb, size - 8);
libavformat/riffenc.c:    uint8_t *riff_extradata       = temp;
libavformat/riffenc.c:    uint8_t *riff_extradata_start = temp;
libavformat/riffenc.c:        bytestream_put_le16(&riff_extradata, 1);    /* wID */
libavformat/riffenc.c:        bytestream_put_le32(&riff_extradata, 2);    /* fdwFlags */
libavformat/riffenc.c:        bytestream_put_le16(&riff_extradata, 1152); /* nBlockSize */
libavformat/riffenc.c:        bytestream_put_le16(&riff_extradata, 1);    /* nFramesPerBlock */
libavformat/riffenc.c:        bytestream_put_le16(&riff_extradata, 1393); /* nCodecDelay */
libavformat/riffenc.c:        bytestream_put_le16(&riff_extradata, 2);
libavformat/riffenc.c:        bytestream_put_le32(&riff_extradata, par->bit_rate);
libavformat/riffenc.c:        bytestream_put_le16(&riff_extradata, par->channels == 2 ? 1 : 8);
libavformat/riffenc.c:        bytestream_put_le16(&riff_extradata, 0);
libavformat/riffenc.c:        bytestream_put_le16(&riff_extradata, 1);
libavformat/riffenc.c:        bytestream_put_le16(&riff_extradata, 16);
libavformat/riffenc.c:        bytestream_put_le32(&riff_extradata, 0);
libavformat/riffenc.c:        bytestream_put_le32(&riff_extradata, 0);
libavformat/riffenc.c:        bytestream_put_le32(&riff_extradata, 0x9ace0002); /* extradata needed for msacm g723.1 codec */
libavformat/riffenc.c:        bytestream_put_le32(&riff_extradata, 0xaea2f732);
libavformat/riffenc.c:        bytestream_put_le16(&riff_extradata, 0xacde);
libavformat/riffenc.c:        bytestream_put_le16(&riff_extradata, frame_size);
libavformat/riffenc.c:    } else if (par->extradata_size) {
libavformat/riffenc.c:        riff_extradata_start = par->extradata;
libavformat/riffenc.c:        riff_extradata       = par->extradata + par->extradata_size;
libavformat/riffenc.c:        avio_wl16(pb, riff_extradata - riff_extradata_start + 22);
libavformat/riffenc.c:               riff_extradata - riff_extradata_start) {
libavformat/riffenc.c:        avio_wl16(pb, riff_extradata - riff_extradata_start); /* cbSize */
libavformat/riffenc.c:    avio_write(pb, riff_extradata_start, riff_extradata - riff_extradata_start);
libavformat/riffenc.c:                       int for_asf, int ignore_extradata, int rgb_frame_is_flipped)
libavformat/riffenc.c:    int flipped_extradata = (par->extradata_size >= 9 &&
libavformat/riffenc.c:                            !memcmp(par->extradata + par->extradata_size - 9, "BottomUp", 9));
libavformat/riffenc.c:    int keep_height = flipped_extradata || rgb_frame_is_flipped;
libavformat/riffenc.c:    int extradata_size = par->extradata_size - 9*flipped_extradata;
libavformat/riffenc.c:    avio_wl32(pb, 40 + (ignore_extradata || pal_avi ? 0 : extradata_size));
libavformat/riffenc.c:    if (!ignore_extradata) {
libavformat/riffenc.c:        if (par->extradata_size) {
libavformat/riffenc.c:            avio_write(pb, par->extradata, extradata_size);
libavformat/riffenc.c:            if (!for_asf && extradata_size & 1)
libavformat/acm.c:    ret = ff_get_extradata(s, st->codecpar, s->pb, 14);
libavformat/acm.c:    st->codecpar->channels    = AV_RL16(st->codecpar->extradata +  8);
libavformat/acm.c:    st->codecpar->sample_rate = AV_RL16(st->codecpar->extradata + 10);
libavformat/acm.c:    st->duration           = AV_RL32(st->codecpar->extradata +  4) / st->codecpar->channels;
libavformat/nutdec.c:    GET_V(st->codecpar->extradata_size, tmp < (1 << 30));
libavformat/nutdec.c:    if (st->codecpar->extradata_size) {
libavformat/nutdec.c:        ret = ff_get_extradata(s, st->codecpar, bc,
libavformat/nutdec.c:                               st->codecpar->extradata_size);
libavformat/nutdec.c:        av_freep(&st->codecpar->extradata);
libavformat/nutdec.c:        st->codecpar->extradata_size = 0;
libavformat/matroskadec.c:    /* real audio header (extracted from extradata) */
libavformat/matroskadec.c:        uint8_t *extradata = NULL;
libavformat/matroskadec.c:        int extradata_size = 0;
libavformat/matroskadec.c:        int extradata_offset = 0;
libavformat/matroskadec.c:            extradata_offset    = 40;
libavformat/matroskadec.c:            extradata_offset = FFMIN(track->codec_priv.size, 18);
libavformat/matroskadec.c:            extradata   = av_mallocz(5 + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/matroskadec.c:            if (!extradata)
libavformat/matroskadec.c:            extradata[0] = (profile << 3) | ((sri & 0x0E) >> 1);
libavformat/matroskadec.c:            extradata[1] = ((sri & 0x01) << 7) | (track->audio.channels << 3);
libavformat/matroskadec.c:                extradata[2]   = 0x56;
libavformat/matroskadec.c:                extradata[3]   = 0xE5;
libavformat/matroskadec.c:                extradata[4]   = 0x80 | (sri << 3);
libavformat/matroskadec.c:                extradata_size = 5;
libavformat/matroskadec.c:                extradata_size = 2;
libavformat/matroskadec.c:            extradata_size = 12 + track->codec_priv.size;
libavformat/matroskadec.c:            extradata      = av_mallocz(extradata_size +
libavformat/matroskadec.c:            if (!extradata)
libavformat/matroskadec.c:            AV_WB32(extradata, extradata_size);
libavformat/matroskadec.c:            memcpy(&extradata[4], "alac", 4);
libavformat/matroskadec.c:            AV_WB32(&extradata[8], 0);
libavformat/matroskadec.c:            memcpy(&extradata[12], track->codec_priv.data,
libavformat/matroskadec.c:            extradata_size = 22;
libavformat/matroskadec.c:            extradata      = av_mallocz(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/matroskadec.c:            if (!extradata)
libavformat/matroskadec.c:            ptr = extradata;
libavformat/matroskadec.c:            extradata_offset = 26;
libavformat/matroskadec.c:                extradata_offset       = 78;
libavformat/matroskadec.c:            ret = matroska_parse_flac(s, track, &extradata_offset);
libavformat/matroskadec.c:            extradata_size = 2;
libavformat/matroskadec.c:            extradata = av_mallocz(2 + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/matroskadec.c:            if (!extradata)
libavformat/matroskadec.c:            AV_WL16(extradata, 0x410);
libavformat/matroskadec.c:               make sure that it's not exported as extradata. */
libavformat/matroskadec.c:               updated to handle isobmff style extradata this can be removed. */
libavformat/matroskadec.c:            extradata_offset = 4;
libavformat/matroskadec.c:        track->codec_priv.size -= extradata_offset;
libavformat/matroskadec.c:        if (!st->codecpar->extradata) {
libavformat/matroskadec.c:            if (extradata) {
libavformat/matroskadec.c:                st->codecpar->extradata      = extradata;
libavformat/matroskadec.c:                st->codecpar->extradata_size = extradata_size;
libavformat/matroskadec.c:                if (ff_alloc_extradata(st->codecpar, track->codec_priv.size))
libavformat/matroskadec.c:                memcpy(st->codecpar->extradata,
libavformat/matroskadec.c:                       track->codec_priv.data + extradata_offset,
libavformat/matroskadec.c:                if (ff_alloc_extradata(st->codecpar, attachments[j].bin.size))
libavformat/matroskadec.c:                memcpy(st->codecpar->extradata, attachments[j].bin.data,
libavformat/matroskadec.c:    av_assert1(track->stream->codecpar->extradata_size >= 2);
libavformat/matroskadec.c:    ver = AV_RL16(track->stream->codecpar->extradata);
libavformat/microdvdenc.c:    if (par->extradata && par->extradata_size > 0) {
libavformat/microdvdenc.c:        avio_write(s->pb, par->extradata, par->extradata_size);
libavformat/genh.c:    case  7: ret = ff_alloc_extradata(st->codecpar, 2);
libavformat/genh.c:             AV_WL16(st->codecpar->extradata, 3);
libavformat/genh.c:        ff_alloc_extradata(st->codecpar, 32 * st->codecpar->channels);
libavformat/genh.c:                avio_read(s->pb, st->codecpar->extradata + 32 * ch, 32);
libavformat/xmv.c:    int     has_extradata; ///< Does the video packet contain extra data?
libavformat/xmv.c:    uint8_t extradata[4];  ///< The extra data
libavformat/xmv.c:static void xmv_read_extradata(uint8_t *extradata, AVIOContext *pb)
libavformat/xmv.c:    /* Read the XMV extradata */
libavformat/xmv.c:    /* Write it back as standard WMV2 extradata */
libavformat/xmv.c:    AV_WB32(extradata, data);
libavformat/xmv.c:    xmv->video.has_extradata = (data[3] & 0x80) != 0;
libavformat/xmv.c:        if (xmv->video.has_extradata) {
libavformat/xmv.c:            xmv_read_extradata(xmv->video.extradata, pb);
libavformat/xmv.c:                if (vst->codecpar->extradata_size < 4) {
libavformat/xmv.c:                    if ((ret = ff_alloc_extradata(vst->codecpar, 4)) < 0)
libavformat/xmv.c:                memcpy(vst->codecpar->extradata, xmv->video.extradata, 4);
libavformat/utils.c:               data and discard it (ignored streams, junk, extradata).
libavformat/utils.c:         * SPS and PPS to extradata during multi-threaded decoding. */
libavformat/utils.c:int ff_alloc_extradata(AVCodecParameters *par, int size)
libavformat/utils.c:    av_freep(&par->extradata);
libavformat/utils.c:    par->extradata_size = 0;
libavformat/utils.c:    par->extradata = av_malloc(size + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/utils.c:    if (!par->extradata)
libavformat/utils.c:    memset(par->extradata + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/utils.c:    par->extradata_size = size;
libavformat/utils.c:int ff_get_extradata(AVFormatContext *s, AVCodecParameters *par, AVIOContext *pb, int size)
libavformat/utils.c:    int ret = ff_alloc_extradata(par, size);
libavformat/utils.c:    ret = avio_read(pb, par->extradata, size);
libavformat/utils.c:        av_freep(&par->extradata);
libavformat/utils.c:        par->extradata_size = 0;
libavformat/utils.c:        av_log(s, AV_LOG_ERROR, "Failed to read extradata of size %d\n", size);
libavformat/utils.c:static int extract_extradata_check(AVStream *st)
libavformat/utils.c:    f = av_bsf_get_by_name("extract_extradata");
libavformat/utils.c:static int extract_extradata_init(AVStream *st)
libavformat/utils.c:    f = av_bsf_get_by_name("extract_extradata");
libavformat/utils.c:    ret = extract_extradata_check(st);
libavformat/utils.c:    sti->extract_extradata.pkt = av_packet_alloc();
libavformat/utils.c:    if (!sti->extract_extradata.pkt)
libavformat/utils.c:    ret = av_bsf_alloc(f, &sti->extract_extradata.bsf);
libavformat/utils.c:    ret = avcodec_parameters_copy(sti->extract_extradata.bsf->par_in,
libavformat/utils.c:    sti->extract_extradata.bsf->time_base_in = st->time_base;
libavformat/utils.c:    ret = av_bsf_init(sti->extract_extradata.bsf);
libavformat/utils.c:    sti->extract_extradata.inited = 1;
libavformat/utils.c:    av_bsf_free(&sti->extract_extradata.bsf);
libavformat/utils.c:    av_packet_free(&sti->extract_extradata.pkt);
libavformat/utils.c:static int extract_extradata(AVStream *st, const AVPacket *pkt)
libavformat/utils.c:    if (!sti->extract_extradata.inited) {
libavformat/utils.c:        ret = extract_extradata_init(st);
libavformat/utils.c:    if (sti->extract_extradata.inited && !sti->extract_extradata.bsf)
libavformat/utils.c:    pkt_ref = sti->extract_extradata.pkt;
libavformat/utils.c:    ret = av_bsf_send_packet(sti->extract_extradata.bsf, pkt_ref);
libavformat/utils.c:    while (ret >= 0 && !sti->avctx->extradata) {
libavformat/utils.c:        ret = av_bsf_receive_packet(sti->extract_extradata.bsf, pkt_ref);
libavformat/utils.c:                sti->avctx->extradata      = side_data->data;
libavformat/utils.c:                sti->avctx->extradata_size = side_data->size;
libavformat/utils.c:         * SPS and PPS to extradata during multi-threaded decoding. */
libavformat/utils.c:            if (!st->internal->avctx->extradata &&
libavformat/utils.c:                (!st->internal->extract_extradata.inited ||
libavformat/utils.c:                 st->internal->extract_extradata.bsf) &&
libavformat/utils.c:                extract_extradata_check(st))
libavformat/utils.c:        if (!st->internal->avctx->extradata) {
libavformat/utils.c:            ret = extract_extradata(st, pkt);
libavformat/utils.c:        av_bsf_free(&ic->streams[i]->internal->extract_extradata.bsf);
libavformat/utils.c:        av_packet_free(&ic->streams[i]->internal->extract_extradata.pkt);
libavformat/utils.c:        av_bsf_free(&st->internal->extract_extradata.bsf);
libavformat/utils.c:        av_packet_free(&st->internal->extract_extradata.pkt);
libavformat/utils.c:int ff_generate_avci_extradata(AVStream *st)
libavformat/utils.c:    static const uint8_t avci100_1080p_extradata[] = {
libavformat/utils.c:    static const uint8_t avci100_1080i_extradata[] = {
libavformat/utils.c:    static const uint8_t avci50_1080p_extradata[] = {
libavformat/utils.c:    static const uint8_t avci50_1080i_extradata[] = {
libavformat/utils.c:    static const uint8_t avci100_720p_extradata[] = {
libavformat/utils.c:    static const uint8_t avci50_720p_extradata[] = {
libavformat/utils.c:            data = avci100_1080p_extradata;
libavformat/utils.c:            size = sizeof(avci100_1080p_extradata);
libavformat/utils.c:            data = avci100_1080i_extradata;
libavformat/utils.c:            size = sizeof(avci100_1080i_extradata);
libavformat/utils.c:            data = avci50_1080p_extradata;
libavformat/utils.c:            size = sizeof(avci50_1080p_extradata);
libavformat/utils.c:            data = avci50_1080i_extradata;
libavformat/utils.c:            size = sizeof(avci50_1080i_extradata);
libavformat/utils.c:        data = avci100_720p_extradata;
libavformat/utils.c:        size = sizeof(avci100_720p_extradata);
libavformat/utils.c:        data = avci50_720p_extradata;
libavformat/utils.c:        size = sizeof(avci50_720p_extradata);
libavformat/utils.c:    if ((ret = ff_alloc_extradata(st->codecpar, size)) < 0)
libavformat/utils.c:    memcpy(st->codecpar->extradata, data, size);
libavformat/utils.c:int ff_bprint_to_codecpar_extradata(AVCodecParameters *par, struct AVBPrint *buf)
libavformat/utils.c:    par->extradata = str;
libavformat/utils.c:    /* Note: the string is NUL terminated (so extradata can be read as a
libavformat/utils.c:     * extradata is copied, it is also padded with AV_INPUT_BUFFER_PADDING_SIZE
libavformat/utils.c:    par->extradata_size = buf->len;
libavformat/matroskaenc.c:    err = avpriv_split_xiph_headers(par->extradata, par->extradata_size,
libavformat/matroskaenc.c:    if (par->extradata && par->extradata_size == 2)
libavformat/matroskaenc.c:        avio_write(pb, par->extradata, 2);
libavformat/matroskaenc.c:    int ret = ff_flac_write_header(pb, par->extradata, par->extradata_size,
libavformat/matroskaenc.c:                                const uint8_t *extradata, int extradata_size,
libavformat/matroskaenc.c:    ret = avpriv_mpeg4audio_get_config2(&mp4ac, extradata, extradata_size, 1, s);
libavformat/matroskaenc.c:    /* Don't abort if the failure is because of missing extradata. Assume in that
libavformat/matroskaenc.c:     * case a bitstream filter will provide the muxer with the extradata in the
libavformat/matroskaenc.c:     * to write the sample rate elements once the extradata shows up, anyway. */
libavformat/matroskaenc.c:    if (ret < 0 && (extradata_size || !IS_SEEKABLE(s->pb, mkv))) {
libavformat/matroskaenc.c:               "Error parsing AAC extradata, unable to determine samplerate.\n");
libavformat/matroskaenc.c:         * header and no extradata is available. The space for this element has
libavformat/matroskaenc.c:         * extradata shows up in the first packet, as there's no way to know if
libavformat/matroskaenc.c:        return ff_isom_write_avcc(dyn_cp, par->extradata,
libavformat/matroskaenc.c:                                  par->extradata_size);
libavformat/matroskaenc.c:        return ff_isom_write_hvcc(dyn_cp, par->extradata,
libavformat/matroskaenc.c:                                  par->extradata_size, 0);
libavformat/matroskaenc.c:        if (par->extradata_size)
libavformat/matroskaenc.c:            return ff_isom_write_av1c(dyn_cp, par->extradata,
libavformat/matroskaenc.c:                                      par->extradata_size);
libavformat/matroskaenc.c:        if (par->extradata_size < 36) {
libavformat/matroskaenc.c:                   "Invalid extradata found, ALAC expects a 36-byte "
libavformat/matroskaenc.c:            avio_write(dyn_cp, par->extradata + 12,
libavformat/matroskaenc.c:                       par->extradata_size - 12);
libavformat/matroskaenc.c:        if (par->extradata_size)
libavformat/matroskaenc.c:            avio_write(dyn_cp, par->extradata, par->extradata_size);
libavformat/matroskaenc.c:        } else if (par->extradata_size && par->codec_id != AV_CODEC_ID_TTA)
libavformat/matroskaenc.c:            avio_write(dyn_cp, par->extradata, par->extradata_size);
libavformat/matroskaenc.c:                && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id)
libavformat/matroskaenc.c:                avio_wb32(dyn_cp, 0x5a + par->extradata_size);
libavformat/matroskaenc.c:            avio_write(dyn_cp, par->extradata, par->extradata_size);
libavformat/matroskaenc.c:        ret = get_aac_sample_rates(s, mkv, par->extradata, par->extradata_size,
libavformat/matroskaenc.c:        put_ebml_binary(dyn_cp, MATROSKA_ID_FILEDATA, st->codecpar->extradata, st->codecpar->extradata_size);
libavformat/matroskaenc.c:    if (par->codec_id == AV_CODEC_ID_H264 && par->extradata_size > 0 &&
libavformat/matroskaenc.c:        (AV_RB24(par->extradata) == 1 || AV_RB32(par->extradata) == 1)) {
libavformat/matroskaenc.c:    } else if (par->codec_id == AV_CODEC_ID_HEVC && par->extradata_size > 6 &&
libavformat/matroskaenc.c:               (AV_RB24(par->extradata) == 1 || AV_RB32(par->extradata) == 1)) {
libavformat/matroskaenc.c:        /* extradata is Annex B, assume the bitstream is too and convert it */
libavformat/matroskaenc.c:            ret = ff_alloc_extradata(par, side_data_size);
libavformat/matroskaenc.c:            memcpy(par->extradata, side_data, side_data_size);
libavformat/matroskaenc.c:        } else if (!par->extradata_size && !track->sample_rate) {
libavformat/matroskaenc.c:            // No extradata (codecpar or packet side data).
libavformat/matroskaenc.c:            av_log(s, AV_LOG_ERROR, "Error parsing AAC extradata, unable to determine samplerate.\n");
libavformat/matroskaenc.c:            uint8_t *old_extradata = par->extradata;
libavformat/matroskaenc.c:            if (side_data_size != par->extradata_size) {
libavformat/matroskaenc.c:            par->extradata = side_data;
libavformat/matroskaenc.c:            par->extradata = old_extradata;
libavformat/matroskaenc.c:    // FIXME: Remove the following once libaom starts propagating extradata during init()
libavformat/matroskaenc.c:        if (side_data_size && mkv->track.bc && !par->extradata_size) {
libavformat/matroskaenc.c:            ret = ff_alloc_extradata(par, side_data_size);
libavformat/matroskaenc.c:            memcpy(par->extradata, side_data, side_data_size);
libavformat/matroskaenc.c:        } else if (!par->extradata_size)
libavformat/matroskaenc.c:            av_log(s, AV_LOG_DEBUG, "Ignoring new extradata in a packet for stream %d.\n", pkt->stream_index);
libavformat/hcom.c:    ret = ff_alloc_extradata(st->codecpar, dict_entries * 4 + 7);
libavformat/hcom.c:    AV_WB16(st->codecpar->extradata, dict_entries);
libavformat/hcom.c:    AV_WB32(st->codecpar->extradata + 2, compresstype);
libavformat/hcom.c:    avio_read(s->pb, st->codecpar->extradata + 6, dict_entries * 4);
libavformat/hcom.c:    st->codecpar->extradata[dict_entries * 4 + 6] = avio_r8(s->pb);
libavformat/riff.h: * bits_per_encoded_sample fields. Does not read extradata.
libavformat/riff.h:void ff_put_bmp_header(AVIOContext *pb, AVCodecParameters *par, int for_asf, int ignore_extradata, int rgb_frame_is_flipped);
libavformat/rtpenc_latm.c:    if ((s1->streams[0]->codecpar->extradata_size) == 0) {
libavformat/internal.h:    /* the context for extracting extradata in find_stream_info()
libavformat/internal.h:    } extract_extradata;
libavformat/internal.h: * Generate standard extradata for AVC-Intra based on width/height and field
libavformat/internal.h:int ff_generate_avci_extradata(AVStream *st);
libavformat/internal.h: * Allocate extradata with additional AV_INPUT_BUFFER_PADDING_SIZE at end
libavformat/internal.h: * Previously allocated extradata in par will be freed.
libavformat/internal.h: * @param size size of extradata
libavformat/internal.h:int ff_alloc_extradata(AVCodecParameters *par, int size);
libavformat/internal.h: * Allocate extradata with additional AV_INPUT_BUFFER_PADDING_SIZE at end
libavformat/internal.h: * @param size size of extradata
libavformat/internal.h:int ff_get_extradata(AVFormatContext *s, AVCodecParameters *par, AVIOContext *pb, int size);
libavformat/internal.h: * Finalize buf into extradata and set its size appropriately.
libavformat/internal.h:int ff_bprint_to_codecpar_extradata(AVCodecParameters *par, struct AVBPrint *buf);
libavformat/aiffdec.c:            if ((ret = ff_get_extradata(s, st->codecpar, pb, size)) < 0)
libavformat/aiffdec.c:                st->codecpar->block_align = AV_RB32(st->codecpar->extradata+11*4);
libavformat/aiffdec.c:                aiff->block_duration = AV_RB32(st->codecpar->extradata+9*4);
libavformat/aiffdec.c:                    rate = st->codecpar->extradata[24];
libavformat/flacenc.c:    ret = ff_flac_write_header(s->pb, par->extradata,
libavformat/flacenc.c:                               par->extradata_size, 0);
libavformat/rtpdec_mpeg4.c:    if ((ret = ff_alloc_extradata(par, len)) < 0)
libavformat/rtpdec_mpeg4.c:    ff_hex_to_data(par->extradata, value);
libavformat/assdec.c:    res = ff_bprint_to_codecpar_extradata(st->codecpar, &header);
libavformat/flacdec.c:            st->codecpar->extradata      = buffer;
libavformat/flacdec.c:            st->codecpar->extradata_size = metadata_size;
libavformat/flacdec.c:            samplerate = AV_RB24(st->codecpar->extradata + 10) >> 4;
libavformat/flacdec.c:            samples    = (AV_RB64(st->codecpar->extradata + 13) >> 24) & ((1ULL << 36) - 1);
libavformat/sierravmd.c:        if ((ret = ff_alloc_extradata(vst->codecpar, VMD_HEADER_SIZE)) < 0)
libavformat/sierravmd.c:        memcpy(vst->codecpar->extradata, vmd->vmd_header, VMD_HEADER_SIZE);
libavformat/rtpdec_xiph.c:    unsigned num_packed, num_headers, length, length1, length2, extradata_alloc;
libavformat/rtpdec_xiph.c:    extradata_alloc = length + length/255 + 3 + AV_INPUT_BUFFER_PADDING_SIZE;
libavformat/rtpdec_xiph.c:    if ((ret = ff_alloc_extradata(par, extradata_alloc)) < 0) {
libavformat/rtpdec_xiph.c:    ptr = par->extradata;
libavformat/rtpdec_xiph.c:    par->extradata_size = ptr - par->extradata;
libavformat/rtpdec_xiph.c:    memset(ptr, 0, extradata_alloc - par->extradata_size);
libavformat/subviewerdec.c:            if (!st->codecpar->extradata) { // header not finalized yet
libavformat/subviewerdec.c:                    res = ff_bprint_to_codecpar_extradata(st->codecpar, &header);
libavformat/smacker.c:    if ((ret = ff_alloc_extradata(par, treesize + 16)) < 0) {
libavformat/smacker.c:               "Cannot allocate %"PRIu32" bytes of extradata\n",
libavformat/smacker.c:    if ((ret = ffio_read_size(pb, par->extradata, 16)) < 0)
libavformat/smacker.c:        /* load trees to extradata, they will be unpacked by decoder */
libavformat/smacker.c:        (ret = ffio_read_size(pb, par->extradata + 16,
libavformat/smacker.c:                              par->extradata_size - 16)) < 0) {
libavformat/rl2.c: * extradata:
libavformat/rl2.c:    /** allocate and fill extradata */
libavformat/rl2.c:    st->codecpar->extradata_size = EXTRADATA1_SIZE;
libavformat/rl2.c:        st->codecpar->extradata_size += back_size;
libavformat/rl2.c:    ret = ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size);
libavformat/flvenc.c:            if (!par->extradata_size && (flv->flags & FLV_AAC_SEQ_HEADER_DETECT)) {
libavformat/flvenc.c:            avio_write(pb, par->extradata, par->extradata_size);
libavformat/flvenc.c:            ff_isom_write_avcc(pb, par->extradata, par->extradata_size);
libavformat/flvenc.c:        if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {
libavformat/flvenc.c:            ret = ff_alloc_extradata(par, side_size);
libavformat/flvenc.c:            memcpy(par->extradata, side, side_size);
libavformat/flvenc.c:        /* check if extradata looks like mp4 formatted */
libavformat/flvenc.c:        if (par->extradata_size > 0 && *(uint8_t*)par->extradata != 1)
libavformat/flvenc.c:            if (par->extradata_size)
libavformat/flvenc.c:                avio_w8(pb, par->extradata[0]);
libavformat/argo_brp.c:    uint32_t extradata_size;
libavformat/argo_brp.c:    } extradata;
libavformat/argo_brp.c:static int read_extradata(AVFormatContext *s, const ArgoBRPStreamHeader *hdr,
libavformat/argo_brp.c:        if ((ret = avio_skip(s->pb, hdr->extradata_size)) < 0)
libavformat/argo_brp.c:    if (hdr->extradata_size != size) {
libavformat/argo_brp.c:        av_log(s, AV_LOG_ERROR, "Invalid %s extradata size %u, expected %u\n",
libavformat/argo_brp.c:               name, hdr->extradata_size, size);
libavformat/argo_brp.c:        hdr->extradata_size = AV_RL32(buf + 16);
libavformat/argo_brp.c:        if ((ret = read_extradata(s, hdr, buf, sizeof(buf))) < 0) {
libavformat/argo_brp.c:            ArgoBVIDHeader *bvid = &hdr->extradata.bvid;
libavformat/argo_brp.c:            ff_argo_asf_parse_file_header(&hdr->extradata.basf, buf);
libavformat/argo_brp.c:            if ((ret = ff_argo_asf_validate_file_header(s, &hdr->extradata.basf)) < 0)
libavformat/argo_brp.c:            st->nb_frames = hdr->extradata.basf.num_chunks;
libavformat/argo_brp.c:            ArgoMASKHeader *mask = &hdr->extradata.mask;
libavformat/argo_brp.c:        av_assert0(brp->streams[brp->basf.index].extradata_size == ASF_FILE_HEADER_SIZE);
libavformat/argo_brp.c:        if (i != 0 && hdr->extradata.basf.version_major == 1 && hdr->extradata.basf.version_minor == 1)
libavformat/argo_brp.c:            hdr->extradata.basf.version_minor = 2;
libavformat/argo_brp.c:        if ((ret = ff_argo_asf_fill_stream(s, st, &hdr->extradata.basf, &brp->basf.ckhdr)) < 0)
libavformat/argo_brp.c:        pkt->duration = av_rescale_rnd(1, st->duration, shdr->extradata.bvid.num_frames, AV_ROUND_UP);
libavformat/dashenc.c:            if (par->extradata_size >= 2) {
libavformat/dashenc.c:                int aot = par->extradata[0] >> 3;
libavformat/dashenc.c:                    aot = ((AV_RB16(par->extradata) >> 5) & 0x3f) + 32;
libavformat/dashenc.c:        uint8_t *extradata = par->extradata;
libavformat/dashenc.c:        int extradata_size = par->extradata_size;
libavformat/dashenc.c:        if (!extradata_size)
libavformat/dashenc.c:        if (extradata[0] != 1) {
libavformat/dashenc.c:            if (ff_isom_write_avcc(pb, extradata, extradata_size) < 0) {
libavformat/dashenc.c:            extradata_size = avio_close_dyn_buf(pb, &extradata);
libavformat/dashenc.c:            tmpbuf = extradata;
libavformat/dashenc.c:        if (extradata_size >= 4)
libavformat/dashenc.c:                        extradata[1], extradata[2], extradata[3]);
libavformat/dashenc.c:        if (!par->extradata_size)
libavformat/dashenc.c:        if (ff_av1_parse_seq_header(&seq, par->extradata, par->extradata_size) < 0)
libavformat/dashenc.c:static int update_stream_extradata(AVFormatContext *s, OutputStream *os,
libavformat/dashenc.c:    uint8_t *extradata;
libavformat/dashenc.c:    buffer_size_t extradata_size;
libavformat/dashenc.c:    if (par->extradata_size)
libavformat/dashenc.c:    extradata = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &extradata_size);
libavformat/dashenc.c:    if (!extradata_size)
libavformat/dashenc.c:    ret = ff_alloc_extradata(par, extradata_size);
libavformat/dashenc.c:    memcpy(par->extradata, extradata, extradata_size);
libavformat/dashenc.c:    ret = update_stream_extradata(s, os, pkt, &st->avg_frame_rate);
libavformat/omaenc.c:        if (par->extradata_size == 14) /* WAV format extradata */
libavformat/omaenc.c:            isjointstereo = par->extradata[6] != 0;
libavformat/omaenc.c:        else if(par->extradata_size == 10) /* RM format extradata */
libavformat/omaenc.c:            isjointstereo = par->extradata[8] == 0x12;
libavformat/omaenc.c:            av_log(s, AV_LOG_ERROR, "ATRAC3: Unsupported extradata size\n");
libavformat/apm.c:static void apm_parse_extradata(APMExtraData *ext, const uint8_t *buf)
libavformat/apm.c:    APMExtraData extradata;
libavformat/apm.c:     * This is 98% a WAVEFORMATEX, but there's something screwy with the extradata
libavformat/apm.c:    apm_parse_extradata(&extradata, buf);
libavformat/apm.c:    if (extradata.magic != APM_TAG_VS12 || extradata.data != APM_TAG_DATA)
libavformat/apm.c:    if (extradata.state.has_saved) {
libavformat/apm.c:    if ((ret = ff_alloc_extradata(par, APM_EXTRADATA_SIZE)) < 0)
libavformat/apm.c:    /* Use the entire state as extradata. */
libavformat/apm.c:    memcpy(par->extradata, buf + 20, APM_EXTRADATA_SIZE);
libavformat/apm.c:    st->duration    = extradata.data_size *
libavformat/apm.c:    if (par->extradata_size != APM_EXTRADATA_SIZE) {
libavformat/apm.c:        av_log(s, AV_LOG_ERROR, "Invalid/missing extradata\n");
libavformat/apm.c:     * Build the extradata. Assume the codec's given us correct data.
libavformat/apm.c:    memcpy( buf + 20, par->extradata, APM_EXTRADATA_SIZE);
libavformat/rsd.c:        if ((ret = ff_alloc_extradata(par, 34)) < 0)
libavformat/rsd.c:        memset(par->extradata, 0, 34);
libavformat/rsd.c:        if ((ret = ff_get_extradata(s, par, s->pb, 32)) < 0)
libavformat/rsd.c:        if ((ret = ff_alloc_extradata(st->codecpar, 32 * par->channels)) < 0)
libavformat/rsd.c:            avio_read(s->pb, st->codecpar->extradata + 32 * i, 32);
libavformat/hca.c:    ret = ff_alloc_extradata(par, s->internal->data_offset);
libavformat/hca.c:    ret = avio_read(pb, par->extradata + 8, par->extradata_size - 8);
libavformat/hca.c:    if (ret < par->extradata_size - 8)
libavformat/hca.c:    AV_WL32(par->extradata, MKTAG('H', 'C', 'A', 0));
libavformat/hca.c:    AV_WB16(par->extradata + 4, version);
libavformat/hca.c:    AV_WB16(par->extradata + 6, s->internal->data_offset);
libavformat/hca.c:    bytestream2_init(&gb, par->extradata + 8, par->extradata_size - 8);
libavformat/wavdec.c:    if ((ret = ff_get_extradata(s, (*st)->codecpar, pb, size)) < 0)
libavformat/wavdec.c:            if ((ret = ff_alloc_extradata(vst->codecpar, 4)) < 0) {
libavformat/wavdec.c:                av_log(s, AV_LOG_ERROR, "Could not allocate extradata.\n");
libavformat/wavdec.c:            AV_WL32(vst->codecpar->extradata, wav->smv_frames_per_jpeg);
libavformat/wavdec.c:        st->codecpar->extradata_size == 2 &&
libavformat/wavdec.c:        AV_RL16(st->codecpar->extradata) == 1) {
libavformat/cinedec.c:        st->codecpar->extradata  = av_strdup("BottomUp");
libavformat/cinedec.c:        if (!st->codecpar->extradata) {
libavformat/cinedec.c:            st->codecpar->extradata_size = 0;
libavformat/cinedec.c:        st->codecpar->extradata_size  = 9;
libavformat/4xm.c:    st->codecpar->extradata      = av_mallocz(4 + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/4xm.c:    if (!st->codecpar->extradata)
libavformat/4xm.c:    st->codecpar->extradata_size = 4;
libavformat/4xm.c:    AV_WL32(st->codecpar->extradata, AV_RL32(buf + 16));
libavformat/vqf.c:    /* put first 12 bytes of COMM chunk in extradata */
libavformat/vqf.c:    if ((ret = ff_alloc_extradata(st->codecpar, 12)) < 0)
libavformat/vqf.c:    memcpy(st->codecpar->extradata, comm_chunk, 12);
libavformat/bintext.c:    if ((ret = ff_alloc_extradata(st->codecpar, 2)) < 0)
libavformat/bintext.c:    st->codecpar->extradata[0] = 16;
libavformat/bintext.c:    st->codecpar->extradata[1] = 0;
libavformat/bintext.c:    st->codecpar->extradata_size = 2;
libavformat/bintext.c:        st->codecpar->extradata_size += 48;
libavformat/bintext.c:        st->codecpar->extradata_size += fontheight * (flags & 0x10 ? 512 : 256);
libavformat/bintext.c:    ret = ff_alloc_extradata(st->codecpar, st->codecpar->extradata_size);
libavformat/bintext.c:    st->codecpar->extradata[0] = fontheight;
libavformat/bintext.c:    st->codecpar->extradata[1] = flags;
libavformat/bintext.c:    if (avio_read(pb, st->codecpar->extradata + 2, st->codecpar->extradata_size - 2) < 0)
libavformat/bintext.c:        bin->fsize = avio_size(pb) - 9 - st->codecpar->extradata_size;
libavformat/bintext.c:        avio_seek(pb, 9 + st->codecpar->extradata_size, SEEK_SET);
libavformat/bintext.c:    if ((ret = ff_alloc_extradata(st->codecpar, 2 + 48 + 4096)) < 0)
libavformat/bintext.c:    st->codecpar->extradata[0] = 16;
libavformat/bintext.c:    st->codecpar->extradata[1] = BINTEXT_PALETTE|BINTEXT_FONT;
libavformat/bintext.c:    if (avio_read(pb, st->codecpar->extradata + 2, 24) < 0)
libavformat/bintext.c:    if (avio_read(pb, st->codecpar->extradata + 2 + 24, 24) < 0)
libavformat/bintext.c:    if (avio_read(pb, st->codecpar->extradata + 2 + 48, 4096) < 0)
libavformat/bintext.c:    if ((ret = ff_alloc_extradata(st->codecpar, 2 + 48 + 4096)) < 0)
libavformat/bintext.c:    st->codecpar->extradata[0] = 16;
libavformat/bintext.c:    st->codecpar->extradata[1] = BINTEXT_PALETTE|BINTEXT_FONT;
libavformat/bintext.c:    if (avio_read(pb, st->codecpar->extradata + 2 + 48, 4096) < 0)
libavformat/bintext.c:    if (avio_read(pb, st->codecpar->extradata + 2, 48) < 0)
libavformat/av1.h: * Writes AV1 extradata (Sequence Header and Metadata OBUs) to the provided
libavformat/hdsenc.c:            // FLV header and all metadata and extradata packets
libavformat/apngenc.c:    if (par->extradata_size) {
libavformat/apngenc.c:        apng->extra_data = av_mallocz(par->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
libavformat/apngenc.c:        apng->extra_data_size = par->extradata_size;
libavformat/apngenc.c:        memcpy(apng->extra_data, par->extradata, par->extradata_size);
libavformat/isom.c:        if ((ret = ff_get_extradata(fc, st->codecpar, pb, len)) < 0)
libavformat/isom.c:            ret = avpriv_mpeg4audio_get_config2(&cfg, st->codecpar->extradata,
libavformat/isom.c:                                                st->codecpar->extradata_size, 1, fc);
libavformat/jacosubdec.c:    /* general/essential directives in the extradata */
libavformat/jacosubdec.c:    ret = ff_bprint_to_codecpar_extradata(st->codecpar, &header);
libavformat/isom.h:    /** extradata array (and size) for multiple stsd */
libavformat/isom.h:    uint8_t **extradata;
libavformat/isom.h:    int *extradata_size;
libavformat/dfa.c:    if ((ret = ff_alloc_extradata(st->codecpar, 2)) < 0)
libavformat/dfa.c:    AV_WL16(st->codecpar->extradata, version);
libavformat/oggparseopus.c:        if ((ret = ff_alloc_extradata(st->codecpar, os->psize)) < 0)
libavformat/oggparseopus.c:        memcpy(st->codecpar->extradata, packet, os->psize);
libavformat/msf.c:            ret = ff_alloc_extradata(st->codecpar, 14);
libavformat/msf.c:            memset(st->codecpar->extradata, 0, st->codecpar->extradata_size);
libavformat/msf.c:            AV_WL16(st->codecpar->extradata, 1); /* version */
libavformat/msf.c:            AV_WL16(st->codecpar->extradata+2, 2048 * st->codecpar->channels); /* unknown size */
libavformat/msf.c:            AV_WL16(st->codecpar->extradata+6, codec == 4 ? 1 : 0); /* joint stereo */
libavformat/msf.c:            AV_WL16(st->codecpar->extradata+8, codec == 4 ? 1 : 0); /* joint stereo (repeat?) */
libavformat/msf.c:            AV_WL16(st->codecpar->extradata+10, 1);
libavformat/realtextdec.c:            /* save header to extradata */
libavformat/realtextdec.c:            if (st->codecpar->extradata) {
libavformat/realtextdec.c:            st->codecpar->extradata = av_strdup(buf.str);
libavformat/realtextdec.c:            if (!st->codecpar->extradata) {
libavformat/realtextdec.c:            st->codecpar->extradata_size = buf.len + 1;
libavformat/mpegtsenc.c:                if (st->codecpar->extradata && st->codecpar->extradata_size >= 19) {
libavformat/mpegtsenc.c:                    if (st->codecpar->extradata[18] == 0 && st->codecpar->channels <= 2) {
libavformat/mpegtsenc.c:                    } else if (st->codecpar->extradata[18] == 1 && st->codecpar->channels <= 8 &&
libavformat/mpegtsenc.c:                               st->codecpar->extradata_size >= 21 + st->codecpar->channels) {
libavformat/mpegtsenc.c:                        if (st->codecpar->extradata[19] == st->codecpar->channels - coupled_stream_counts[st->codecpar->channels] &&
libavformat/mpegtsenc.c:                            st->codecpar->extradata[20] == coupled_stream_counts[st->codecpar->channels] &&
libavformat/mpegtsenc.c:                            memcmp(&st->codecpar->extradata[21], channel_map_a[st->codecpar->channels-1], st->codecpar->channels) == 0) {
libavformat/mpegtsenc.c:                        } else if (st->codecpar->channels >= 2 && st->codecpar->extradata[19] == st->codecpar->channels &&
libavformat/mpegtsenc.c:                                   st->codecpar->extradata[20] == 0 &&
libavformat/mpegtsenc.c:                                   memcmp(&st->codecpar->extradata[21], channel_map_b[st->codecpar->channels-1], st->codecpar->channels) == 0) {
libavformat/mpegtsenc.c:                        av_log(s, AV_LOG_ERROR, "Unsupported Opus channel mapping for family %d", st->codecpar->extradata[18]);
libavformat/mpegtsenc.c:               int extradata_copied = 0;
libavformat/mpegtsenc.c:                   if (st->codecpar->extradata_size - extradata_copied >= 5) {
libavformat/mpegtsenc.c:                       *q++ = st->codecpar->extradata[extradata_copied + 4]; /* subtitling_type */
libavformat/mpegtsenc.c:                       memcpy(q, st->codecpar->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */
libavformat/mpegtsenc.c:                       extradata_copied += 5;
libavformat/mpegtsenc.c:                       if ((st->codecpar->extradata_size == 4) && (extradata_copied == 0)) {
libavformat/mpegtsenc.c:                           /* support of old 4-byte extradata format */
libavformat/mpegtsenc.c:                           memcpy(q, st->codecpar->extradata, 4); /* composition_page_id and ancillary_page_id */
libavformat/mpegtsenc.c:                           extradata_copied += 4;
libavformat/mpegtsenc.c:               int extradata_copied = 0;
libavformat/mpegtsenc.c:                   if (st->codecpar->extradata_size - 1 > extradata_copied) {
libavformat/mpegtsenc.c:                       memcpy(q, st->codecpar->extradata + extradata_copied, 2);
libavformat/mpegtsenc.c:                       extradata_copied += 2;
libavformat/mpegtsenc.c:            st->codecpar->extradata_size > 0) {
libavformat/mpegtsenc.c:        int extradd = (pkt->flags & AV_PKT_FLAG_KEY) ? st->codecpar->extradata_size : 0;
libavformat/mpegtsenc.c:        if (extradd && AV_RB24(st->codecpar->extradata) > 1)
libavformat/mpegtsenc.c:            memcpy(data + 6, st->codecpar->extradata, extradd);
libavformat/mpegtsenc.c:                                        "and extradata missing\n");
libavformat/mpegtsenc.c:        int extradd = (pkt->flags & AV_PKT_FLAG_KEY) ? st->codecpar->extradata_size : 0;
libavformat/mpegtsenc.c:        if (extradd && AV_RB24(st->codecpar->extradata) > 1)
libavformat/mpegtsenc.c:            memcpy(data + 7, st->codecpar->extradata, extradd);
libavformat/mpegtsenc.c:                              (st->codecpar->extradata_size > 0 &&
libavformat/mpegtsenc.c:                               st->codecpar->extradata[0] == 1)))
libavformat/mpegtsenc.c:                              (st->codecpar->extradata_size > 0 &&
libavformat/mpegtsenc.c:                               st->codecpar->extradata[0] == 1)))
libavformat/movenc.h:    int need_rewrite_extradata;
libavformat/wtvenc.c:        int padding = (st->codecpar->extradata_size & 3) ? 4 - (st->codecpar->extradata_size & 3) : 0;
libavformat/wtvenc.c:        avio_wl32(pb, st->codecpar->extradata_size + padding);
libavformat/wtvenc.c:        avio_write(pb, st->codecpar->extradata, st->codecpar->extradata_size);
libavformat/avc.c:int ff_avc_write_annexb_extradata(const uint8_t *in, uint8_t **buf, int *size)
libavformat/rtpenc.c:        if (st->codecpar->extradata_size > 4 && st->codecpar->extradata[0] == 1) {
libavformat/rtpenc.c:            s->nal_length_size = (st->codecpar->extradata[4] & 0x03) + 1;
libavformat/rtpenc.c:        /* Only check for the standardized hvcC version of extradata, keeping
libavformat/rtpenc.c:        if (st->codecpar->extradata_size > 21 && st->codecpar->extradata[0] == 1) {
libavformat/rtpenc.c:            s->nal_length_size = (st->codecpar->extradata[21] & 0x03) + 1;
libavformat/rtpdec_qdm2.c:    int block_size;            ///< from extradata, used as pkt length
libavformat/rtpdec_qdm2.c: * Parse configuration (basically the codec-specific extradata) from
libavformat/rtpdec_qdm2.c: * Item 1 implies a stream configuration without extradata.
libavformat/rtpdec_qdm2.c: * Item 4 implies a stream configuration with extradata (size >= 0x1c).
libavformat/rtpdec_qdm2.c:            case 1: /* stream without extradata */
libavformat/rtpdec_qdm2.c:            case 4: /* stream with extradata */
libavformat/rtpdec_qdm2.c:                ret = ff_alloc_extradata(st->codecpar, 26 + item_len);
libavformat/rtpdec_qdm2.c:                AV_WB32(st->codecpar->extradata, 12);
libavformat/rtpdec_qdm2.c:                memcpy(st->codecpar->extradata + 4, "frma", 4);
libavformat/rtpdec_qdm2.c:                memcpy(st->codecpar->extradata + 8, "QDM2", 4);
libavformat/rtpdec_qdm2.c:                AV_WB32(st->codecpar->extradata + 12, 6 + item_len);
libavformat/rtpdec_qdm2.c:                memcpy(st->codecpar->extradata + 16, "QDCA", 4);
libavformat/rtpdec_qdm2.c:                memcpy(st->codecpar->extradata + 20, p + 2, item_len - 2);
libavformat/rtpdec_qdm2.c:                AV_WB32(st->codecpar->extradata + 18 + item_len, 8);
libavformat/rtpdec_qdm2.c:                AV_WB32(st->codecpar->extradata + 22 + item_len, 0);
libavformat/rtpdec_qdm2.c:             * delay decoder initialization since extradata is
libavformat/nutenc.c:    put_v(bc, par->extradata_size);
libavformat/nutenc.c:    avio_write(bc, par->extradata, par->extradata_size);
libavformat/cafenc.c:        avio_wb64(pb, 12 + par->extradata_size);
libavformat/cafenc.c:        avio_write(pb, par->extradata, par->extradata_size);
libavformat/cafenc.c:        avio_wb64(pb, par->extradata_size);
libavformat/cafenc.c:        avio_write(pb, par->extradata, par->extradata_size);
tests/fate/hevc.mak:# this sample has two stsd entries and needs to reload extradata
tests/fate/hevc.mak:FATE_HEVC-$(call DEMDEC, MOV, HEVC) += fate-hevc-extradata-reload
tests/fate/hevc.mak:fate-hevc-extradata-reload: CMD = framemd5 -i $(TARGET_SAMPLES)/hevc/extradata-reload-multi-stsd.mov -sws_flags bitexact
tests/fate/matroska.mak:# and that FLAC extradata is correctly updated when a packet
tests/fate/matroska.mak:# with sidedata containing new extradata is encountered.
tests/fate/matroska.mak:# the latter's ability to send updated extradata.
tests/fate/matroska.mak:                MATROSKA_DEMUXER MATROSKA_MUXER) += fate-matroska-flac-extradata-update
tests/fate/matroska.mak:fate-matroska-flac-extradata-update: CMD = transcode matroska $(TARGET_SAMPLES)/mkv/flac_channel_layouts.mka \
tests/fate/h264.mak:# this sample has two stsd entries and needs to reload extradata
tests/fate/h264.mak:FATE_H264-$(call DEMDEC,  MOV, H264) += fate-h264-extradata-reload
tests/fate/h264.mak:# this sample has invalid extradata that is not escaped
tests/fate/h264.mak:FATE_H264-$(call DEMDEC,  MOV, H264) += fate-h264-unescaped-extradata
tests/fate/h264.mak:fate-h264-extradata-reload:                       CMD = framemd5 -i $(TARGET_SAMPLES)/h264/extradata-reload-multi-stsd.mov
tests/fate/h264.mak:fate-h264-unescaped-extradata:                    CMD = framecrc -i $(TARGET_SAMPLES)/h264/unescaped_extradata.mp4 -an -frames 10
tests/ref/fate/xmv-demux:#extradata 0:        4, 0x015a00ad
tests/ref/fate/utvideoenc_rgba_none:#extradata 0,                              16, 9881f4423f0a3b5da25a0574d3451eef
tests/ref/fate/segment-adts-to-mkv-header-001:#extradata 0:        2, 0x0030001c
tests/ref/fate/aac-autobsf-adtstoasc:#extradata 0:        2, 0x0030001c
tests/ref/fate/hapqa-extract-nosnappy-to-hapq-mov:extradata_hash=adler32:00000001
tests/ref/fate/mtv:#extradata 0:        9, 0x116c033a
tests/ref/fate/copy-psp:#extradata 0:       51, 0xaf6d1012
tests/ref/fate/copy-psp:#extradata 1:        2, 0x00b200a1
tests/ref/fate/utvideoenc_rgb_none:#extradata 0,                              16, c9a1741fb293b9ad21876492b5425a3b
tests/ref/fate/adtstoasc_ticket3715:#extradata 0:        2, 0x00340022
tests/ref/fate/wmv3-drm-nodec:#extradata 0:        4, 0x021800a2
tests/ref/fate/wmv3-drm-nodec:#extradata 1:       46, 0x63d9043a
tests/ref/fate/matroska-flac-extradata-update:3c721898cf2cf3e2e6c43ad58952bd2d *tests/data/fate/matroska-flac-extradata-update.matroska
tests/ref/fate/matroska-flac-extradata-update:2032 tests/data/fate/matroska-flac-extradata-update.matroska
tests/ref/fate/matroska-flac-extradata-update:#extradata 0:       34, 0x7acb09e7
tests/ref/fate/matroska-flac-extradata-update:#extradata 1:       34, 0x7acb09e7
tests/ref/fate/matroska-flac-extradata-update:#extradata 2:       34, 0x443402dd
tests/ref/fate/utvideoenc_yuv420_none:#extradata 0,                              16, 32fe9f95e57b78773a0fe54c47055a60
tests/ref/fate/mxf-d10-user-comments:#extradata 0:       34, 0x716b05c4
tests/ref/fate/h264_mp4toannexb_ticket5927_2:#extradata 0:       33, 0x84fe08f8
tests/ref/fate/sub2video:#extradata 1:      150, 0x7c99258b
tests/ref/fate/matroska-prores-header-insertion-bz2:#extradata 0:        4, 0x0402019c
tests/ref/fate/matroska-prores-header-insertion-bz2:#extradata 1:        4, 0x0402019c
tests/ref/fate/utvideoenc_rgba_median:#extradata 0,                              16, 9881f4423f0a3b5da25a0574d3451eef
tests/ref/fate/utvideoenc_rgb_median:#extradata 0,                              16, c9a1741fb293b9ad21876492b5425a3b
tests/ref/fate/segment-mp4-to-ts:#extradata 0:       50, 0x4f1b0df9
tests/ref/fate/lmlm4-demux:#extradata 0:       28, 0x2f140538
tests/ref/fate/webm-dash-chapters:#extradata 0:     3469, 0xc6769ddc
tests/ref/fate/utvideoenc_yuv444_none:#extradata 0,                              16, e46c7123194c0ebf19a23e5cefebaa63
tests/ref/fate/segment-adts-to-mkv-header-000:#extradata 0:        2, 0x0030001c
tests/ref/fate/utvideoenc_yuv422_median:#extradata 0,                              16, 7d613a4daaadf19228d42c98deb26024
tests/ref/fate/matroska-zlib-decompression:#extradata 0:      348, 0x5f625922
tests/ref/fate/flv-demux:#extradata 0:       39, 0xf8aa0d44
tests/ref/fate/flv-demux:#extradata 1:        2, 0x00b600a3
tests/ref/fate/utvideoenc_rgba_left:#extradata 0,                              16, 9881f4423f0a3b5da25a0574d3451eef
tests/ref/fate/utvideoenc_yuv420_median:#extradata 0,                              16, 32fe9f95e57b78773a0fe54c47055a60
tests/ref/fate/nc-demux:#extradata 0:       19, 0x1afd0446
tests/ref/fate/utvideoenc_rgb_left:#extradata 0,                              16, c9a1741fb293b9ad21876492b5425a3b
tests/ref/fate/segment-adts-to-mkv-header-002:#extradata 0:        2, 0x0030001c
tests/ref/fate/h264_mp4toannexb_ticket2991:#extradata 0:       47, 0x3a590d55
tests/ref/fate/utvideoenc_yuv422_left:#extradata 0,                              16, 7d613a4daaadf19228d42c98deb26024
tests/ref/fate/utvideoenc_yuv444_median:#extradata 0,                              16, e46c7123194c0ebf19a23e5cefebaa63
tests/ref/fate/ffmpeg-bsf-remove-k:#extradata 0:       30, 0x4a4d065a
tests/ref/fate/av1-annexb-demux:#extradata 0:       13, 0x0e4c033a
tests/ref/fate/wtv-demux:#extradata 0:       86, 0xc7ca09e5
tests/ref/fate/wtv-demux:#extradata 1:       22, 0x12dc010c
tests/ref/fate/hapqa-extract-nosnappy-to-hapalphaonly-mov:extradata_hash=adler32:00000001
tests/ref/fate/matroska-flac-channel-mapping:#extradata 0:       34, 0x7a7909e5
tests/ref/fate/matroska-flac-channel-mapping:#extradata 1:       34, 0x7a7909e5
tests/ref/fate/segment-adts-to-mkv-header-all:#extradata 0:        2, 0x0030001c
tests/ref/fate/matroska-prores-zlib:#extradata 0:        4, 0x040801a2
tests/ref/fate/utvideoenc_yuv422_none:#extradata 0,                              16, 7d613a4daaadf19228d42c98deb26024
tests/ref/fate/ts-small-demux:#extradata 0:       35, 0x83f4073d
tests/ref/fate/mxf-demux:#extradata 0:       18, 0x0b150244
tests/ref/fate/matroska-spherical-mono-remux:#extradata 0:       43, 0x2b0e0d7b
tests/ref/fate/matroska-spherical-mono-remux:#extradata 1:       43, 0x2b0e0d7b
tests/ref/fate/mkv-1242:#extradata 0:       93, 0xc2a32e14
tests/ref/fate/mkv-1242:#extradata 1:        2, 0x00b200a1
tests/ref/fate/h264_mp4toannexb_ticket5927:#extradata 0:       33, 0x84fe08f8
tests/ref/fate/oggopus-demux:#extradata 0:       19, 0x399c0471
tests/ref/fate/ffmpeg-streamloop:#extradata 0,                              42, eb4ec433b0b59dcc24620891ef779635
tests/ref/fate/utvideoenc_yuv420_left:#extradata 0,                              16, 32fe9f95e57b78773a0fe54c47055a60
tests/ref/fate/ts-opus-demux:#extradata 0:       30, 0x53be0347
tests/ref/fate/iv8-demux:#extradata 0:       19, 0x1f2604b9
tests/ref/fate/matroska-mastering-display-metadata:#extradata 0:        4, 0x040901a3
tests/ref/fate/matroska-mastering-display-metadata:#extradata 3:      200, 0x506463a8
tests/ref/fate/ts-demux:#extradata 0:      150, 0xb4192fb9
tests/ref/fate/mkv:#extradata 0:       35, 0xc3b20b70
tests/ref/fate/mkv:#extradata 1:        2, 0x00b200a1
tests/ref/fate/matroska-wavpack-missing-codecprivate:#extradata 0:        2, 0x00240014
tests/ref/fate/matroska-xiph-lacing:#extradata 0:     3766, 0xde3392f7
tests/ref/fate/utvideoenc_yuv444_left:#extradata 0,                              16, e46c7123194c0ebf19a23e5cefebaa63
tools/sidxindex.c:        if (codecpar->extradata_size >= 4 && codecpar->extradata[0] == 1) {
tools/sidxindex.c:                        codecpar->extradata[1], codecpar->extradata[2],
tools/sidxindex.c:                        codecpar->extradata[3]);
tools/sidxindex.c:        if (codecpar->extradata_size >= 2) {
tools/sidxindex.c:            int aot = codecpar->extradata[0] >> 3;
tools/sidxindex.c:                aot = ((AV_RB16(codecpar->extradata) >> 5) & 0x3f) + 32;
tools/target_bsf_fuzzer.c:        int extradata_size;
tools/target_bsf_fuzzer.c:        extradata_size = bytestream2_get_le32(&gbc);
tools/target_bsf_fuzzer.c:            else if (!strcmp(f->name, "extract_extradata"))
tools/target_bsf_fuzzer.c:        if (extradata_size < size) {
tools/target_bsf_fuzzer.c:            bsf->par_in->extradata = av_mallocz(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
tools/target_bsf_fuzzer.c:            if (bsf->par_in->extradata) {
tools/target_bsf_fuzzer.c:                bsf->par_in->extradata_size = extradata_size;
tools/target_bsf_fuzzer.c:                size -= bsf->par_in->extradata_size;
tools/target_bsf_fuzzer.c:                memcpy(bsf->par_in->extradata, data + size, bsf->par_in->extradata_size);
tools/ismindex.c:    track->codec_private      = av_mallocz(codecpar->extradata_size);
tools/ismindex.c:    track->codec_private_size = codecpar->extradata_size;
tools/ismindex.c:    memcpy(track->codec_private, codecpar->extradata, codecpar->extradata_size);
tools/ismindex.c:    if (codecpar->extradata_size < 11 || codecpar->extradata[0] != 1)
tools/ismindex.c:    sps_size = AV_RB16(&codecpar->extradata[6]);
tools/ismindex.c:    if (11 + sps_size > codecpar->extradata_size)
tools/ismindex.c:    avio_write(io, &codecpar->extradata[8], sps_size);
tools/ismindex.c:    pps_size = AV_RB16(&codecpar->extradata[9 + sps_size]);
tools/ismindex.c:    if (11 + sps_size + pps_size > codecpar->extradata_size)
tools/ismindex.c:    avio_write(io, &codecpar->extradata[11 + sps_size], pps_size);
tools/target_dec_fuzzer.c:        int extradata_size;
tools/target_dec_fuzzer.c:        extradata_size = bytestream2_get_le32(&gbc);
tools/target_dec_fuzzer.c:        if (extradata_size < size) {
tools/target_dec_fuzzer.c:            ctx->extradata = av_mallocz(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
tools/target_dec_fuzzer.c:            if (ctx->extradata) {
tools/target_dec_fuzzer.c:                ctx->extradata_size = extradata_size;
tools/target_dec_fuzzer.c:                size -= ctx->extradata_size;
tools/target_dec_fuzzer.c:                memcpy(ctx->extradata, data + size, ctx->extradata_size);
